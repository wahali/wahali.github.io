{"pages":[{"title":"","text":"7D35yajb0z","link":"/baidu_verify_7D35yajb0z.html"}],"posts":[{"title":"Ac自动机","text":"解决多模式串，一个文本串问题。例如：多模式串中有多少种在文本串中出现P3808 【模板】AC自动机（简单版）多模式串在文本串中出现最多的模式串及次数P3796 【模板】AC自动机（加强版）多模式串中每个模式串在文本串中出现的次数+查询优化P5357 【模板】AC自动机（二次加强版）我最开始学习使用的是kuangbin的模板，在模板的基础上修改就能过各种简单题。","link":"/2019/08/26/Ac自动机/"},{"title":"iracus主题个性化配置","text":"2019/7/3 站点无法访问，重定向太多了，过了一段时间又好了，可能配置之后DNS没有及时更新导致的。谷歌收录挺快的，百度收录通过CNAME方式验证了网站，可算验证成功了。尝试修复toc锚点，即目录无法跳转的问题参看帮助，由于我没有对应的文件，我未采用方法1，采用方法2保留到了原版本，解决了该问题 图片放大参照上面那个链接 Cloudflare使用访问变快了，挺不错的，之后不好用了再用别的办法吧。 之前碰到了开启CDN服务不断重定向的问题，通过这个解决了。","link":"/2019/07/02/iracus主题个性化配置/"},{"title":"B树","text":"B-树（平衡多路查找树）若为m阶B-树。定义及性质：1、结点至多m棵子树（对应m阶B树）；2、非叶子节点最少有两棵子树；3、除根之外所有非终端结点至少 $\\lceil$ $m\\over2$$\\rceil$棵子树;4、非终端结点包含以下信息（$n,A_0,K_1,A_1,K_2,,,K_n,A_n$）;n表示结点上关键字个数，$K_i$对应关键字，$A_i$对应指向子树的根节点。由此我们可知，子树个数等于关键字个数加一，由于阶数限制，又由于性质3，所以关键字个数n（$\\lceil$ $m \\over 2$ $\\rceil$ $\\leq$ $n$ $\\leq$ $m-1$）。","link":"/2019/07/10/B树/"},{"title":"dp","text":"CF1183H 线性$dp$，$dp[i][j]$表示前$i$个字符删去$j$个字符形成的不同的子序列，能够构成的本质不同的字符子串的个数。状态转移： $\\color{red}{ } dp[i][j]$ $\\color{red}{ }= dp[i-1][j]$ $\\color{red}{ } +$ $\\color{red}{ }dp[i-1][j-1]$可以由前$i-1$个字符删去$j$个，保留第$i$个字符的状态和前$i-1$个字符删去$j-1$个，并且删去第$i$个字符的状态转移过来。但是存在重复选取的情况，dp[i-1][j] 中以第i个字符结尾长度为i-j的字符子串也可能出现在dp[i-1][j-1]中，如果存在，需要减去。记录第i个字符上次出现的位置pos，以pos为结束的长度为i-j的字符子串个数即是重复个数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;ll pre[30];ll dp[105][105];char s[105];int main(){ ios::sync_with_stdio(false); ll n,k; cin &gt;&gt; n &gt;&gt; k; for(int i = 1;i &lt;= n;++i)cin &gt;&gt; s[i]; dp[0][0] = 1; for(int i = 1;i &lt;= n;++i){ dp[i][0] = 1; for(int j = 1;j &lt;= i;++j){ dp[i][j] = dp[i-1][j] + dp[i-1][j-1]; int pos = pre[s[i]-'a']; if(pos&amp;&amp;pos - i + j&gt;=0) dp[i][j] -= dp[pos-1][pos-i+j]; } pre[s[i]-'a'] = i; } ll cnt = 0; ll ans =0; //for(int i = 0;i&lt;=n;++i)cout &lt;&lt; dp[n][i] &lt;&lt; endl; for(int j = 0;j&lt;=n;++j){ if(dp[n][j]&gt;=k){ ans += k * j; k = 0; break; } else { k -= dp[n][j]; ans += dp[n][j] * j; } } if(k!=0)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/09/10/dp/"},{"title":"FTP记住密码后的麻烦解决","text":"转载自我自己之前CSDN的博客在大一的时候我学校里计算机相关的老师会让我们在ftp服务器上下载作业，我才开始接触ftp服务器。在一次使用时点击了保存密码的选项，之后的登陆就变得很不愉快了。因为记住密码的原因，每次登陆ftp服务器，都会自动进入之前保存的那个用户，无法在同一个服务器上其他的账户上下载东西，也就是当时不知道如何切换到那个服务器上的其他账户。 在网上查阅了近2个小时的方法，才找到了能够解决这个问题的办法，也就是一个登陆ftp服务器的万用方法。 ftp://用户名:密码@地址通过这个方式就可以在已保存密码的情况下，登陆其他的用户了。 希望能帮助到那些萌新小白新生，希望能让那些急于寻找解决办法的人，不要像我那样浪费了很多时间。","link":"/2019/07/04/FTP记住密码后的麻烦解决/"},{"title":"Ubuntu","text":"Ubuntu 安装在VMware上笔记本安装遇到的分辨率和刷新率的问题，先使用设置中调整分辨率再进行安装 VMware Tool文件复制到桌面之后再提取到主目录，不然会报错共享文件夹老挂载不上，","link":"/2019/07/03/Ubuntu/"},{"title":"三分法","text":"第一次搞三分法，懵逼，之后来补题和题解。","link":"/2019/07/16/三分法/"},{"title":"二分图","text":"基本概念无向图G的二分图的充分必要条件： 1G至少有两个点；对于G中每条回路长度得是偶数。 匹配 1对于G的一个子图M，M的边集中任何两条边都不依附于同一个点，则称这个边集是一个匹配，匹配的数量由边数决定。(可以理解左右两堆点，一一匹配，左边的点只能跟右边的一个点匹配) 完美匹配 1匹配中所有顶点都是匹配的点。 交替路 1从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边形成的路径。 增广路 1从一个未匹配点出发，走交替路，途经另一位匹配点，这段路成为增广路，即未匹配边未匹配边加一。 匈牙利算法通过增广路不断“反色”求解最大匹配的问题。二分图最大匹配模板P3386 【模板】二分图匹配二分图最大匹配P1640 [SCOI2010]连续攻击游戏,理解运用二分图，使用时间戳优化。二分图最大匹配372. 棋盘覆盖 理解二分图中的0要素和1要素","link":"/2019/07/04/二分图/"},{"title":"全排列及康拓展开","text":"P1088 火星人 1、会使用next_permutation函数2、了解算法，手写next_permutation函数3、学习使用康拓展开和逆康拓展开 Next_permutation算法描述：每次从后往前找第一个可以修改的位置m（判断条件：当前元素a[m]小于后一个元素a[m+1]），再从后往前找第一个大于需修改位置的元素的位置n(判断条件a[n]&gt;a[m])。修改位置的后面是降序的，找到的第一个大于a[i]的数一定是后面大于a[m]的数中最小的。交换a[m],a[n]。交换完后面的序列还是降序的，我们需要得到最小的序列，所以需要进行一次倒序操作。 代码实现（c++）： 1234567891011121314151617181920212223242526int num[100];int next(int l,int r,int num[]){ //数组的左右端 ,数组从1开始 if(l==r)return; int m =0,n =0; for(int i = r-1;l&gt;=l;--i){ //找需要修改的位置m if(num[i]&lt;num[i+1]){ m = i; break; } } if(m==0)retunr 0; //说明序列已经最大了 全排列结束，返回0 for(int i = r;i&gt;=l;--i){ //找第一个大于num【m】元素的位置 if(num[i]&gt;num[m]){ n = i; break; } } swnump(num[m],num[n]); m++; n = r; while(m&lt;n){ //参照位置之后倒序 swap(num[m],num[n]); m++;n--; } return 1; //有下一个全排列，返回1 } 康拓展开","link":"/2019/07/11/全排列及康拓展开/"},{"title":"初等数论","text":"威尔逊定理判定一个自然数是否为素数的必要充分条件。当且仅当$p$为素数时：$（p-1）!$ $\\equiv-1$ ( mod $p$)。 费马小定理若$p$是质数，对任意整数$a$,$a^p\\equiv$ a( mod $p$)。","link":"/2019/07/29/初等数论/"},{"title":"完全背包","text":"完全背包的应用，将一个数拆成多个数（可重复）的组合，求方案数。如果，求不同素数组合的方案数，则变为01背包求方案数。","link":"/2019/07/18/完全背包/"},{"title":"回文自动机PAM","text":"模板num[i]表示字符串第i个位置为止的后缀回文串中以第i个字母为结尾的回文串的个数；cnt[i]表示本质不同回文串的个数，本质相同的回文串可能在字符串的多个位置出现。cur 指向父亲回文串，当前回文串由父亲回文串拓展(+2)而来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3e5 + 10;struct Palindrome_Aut{ int len[maxn],nx[maxn][26],fail[maxn],cnt[maxn]; //cnt 结点i表示的本质不同的串的个数,fail表示结点i失配后跳转不等于自身的结点i表示的回文串的最长后缀回文串 int last,cur,S[maxn],p,n; //p为新建结点的返回值，S存储插入的字符串，n为总的串长,last记录最后新建的节点的索引,cur指向当前回文串的父亲串 int num[maxn]; //表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 for(int i = 0;i &lt;= 25;++i)nx[p][i] = 0; cnt[p] = 0; len[p] = l; num[p] = 0; return p++; } inline void init(){ p = n = last = 0; newnode(0); newnode(-1); S[0] = -1; //加入任意一个串不会出现的字符 fail[0] = 1; } int get_fail(int x){ while(S[n-len[x] - 1]!=S[n])x = fail[x]; return x; } inline void add(int c){ //插入字符 c -= 'a'; S[++n] = c; int cur = get_fail(last); // if(!nx[cur][c]){ int now = newnode(len[cur]+2); fail[now] = nx[get_fail(fail[cur])][c]; nx[cur][c] = now; num[now] = num[fail[now]] + 1; } last = nx[cur][c]; cnt[last] ++; } void count(){ for(int i = p-1;i &gt;=0;--i){ //逆序累加，保证每个点都会比它的父亲结点先算完，于是父亲节点能算加到所有子孙 cnt[fail[i]]+=cnt[i]; } } }run;int main(){ ios::sync_with_stdio(false); string s; cin &gt;&gt; s; run.init(); for(int i = 0;i&lt;s.length();++i)run.add(s[i]); run.count(); for(int i = 2;i&lt;run.p;++i)cout &lt;&lt; run.cnt[i]; return 0;}","link":"/2019/09/08/回文自动机PAM/"},{"title":"排列组合问题","text":"感谢前人总结，学到了各种的解法排列组合 “n个球放入m个盒子m”问题 总结","link":"/2019/08/10/排列组合问题/"},{"title":"扩展kmp","text":"扩展kmp扩展kmp用来求解一个字符串的最长回文子串和最长重复子串。大佬讲得很详细,有图看起来也很清楚在队友的帮助下，终于看懂了。求解S串的每个后缀与T串的最长前缀匹配长度，需要用到T串每个后缀对T串的最长前缀匹配长度。由👆博客指出的规律，求$T$串的Next数组就相当于用一个与T串相同的$T’$串与T串扩展kmp，求解$T’$的extend就相当于T的Next数组。存储的是对任意前缀的非前缀子串与原串前缀匹配的最长后缀长度。 kmpkmp 中的next数组存储的是以i结尾的非前缀子串与原串的前缀能够匹配的最长长度，匹配长度为$next[i],即子串$ $S[(i-(next[i]-1)),…,i]$ 与子串 $S[1,…,next[i]]$匹配。 (下标从1开始)扩展kmp中的next[i]含义为：S[i]…S[n]与S的最长相同前缀长度，n为S串的长度，下标从1开始。存储对每一个后缀而言的最长前缀匹配长度。 最小表示法字符串首尾相连，找到一个位置，从该位置向后形成的字符串字典序最小。模板：定义i，j，k。i，j为比较的两字符串的头，k为匹配长度 int get_min(string s){ //返回下标 int len = s.length(); int i = 0,j = 1,k = 0,t; while(i&lt; len &amp;&amp; j &lt; len &amp;&amp; k &lt; len){ t = s[(i+k)%len] - s[(j+k)%len]; if(!t)k++; //字符串相等，匹配长度加一 else{ if(t &gt; 0)i += k+1; //i串比j串更大，直接跳过之前匹配的相同的部分长度k else j += k + 1; //j串比i串字典序更大，直接跳过之前匹配的相同的部分长度k if(i == j) j++; // 将字符串起点设置在不同的地方 k = 0; } } return i &gt; j ? j : i; } 模板题：POJ - 1509 Z-function定义一个函数z()，z(i)是指由s[i]开始的字串，与s[0]开始的字串可以匹配到多长。也就是说 s[0…z(i)−1]=s[i…i+z(i)−1]。即存储从i开始的原串的后缀与原串的前缀的的最长前缀匹配长度","link":"/2019/08/26/扩展kmp/"},{"title":"并查集","text":"P1196 [NOI2002]银河英雄传说 代码先附上，题解过两天补。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 3e4+5;int head[MAXN],size[MAXN],dis[MAXN];int find(int x){ if(head[x]==x)return head[x]; int k = head[x]; head[x] = find(head[x]); dis[x] += dis[k]; return head[x];}void UNION(int a,int b){ int dx = find(a); int dy = find(b); dis[dx]+=size[dy]; size[dy]+=size[dx]; head[dx] = dy; return;}int main(){ int t; cin &gt;&gt; t; for(int i = 0;i&lt;MAXN;++i)size[i] = 1,head[i] = i,dis[i] =0; char ch; int a,b; for(int i = 0;i&lt;t;++i){ cin &gt;&gt; ch &gt;&gt; a &gt;&gt; b; if(ch == 'M')UNION(a,b); else{ int dx = find(a); int dy = find(b); if(dx!=dy)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; abs(dis[a]-dis[b])-1 &lt;&lt; endl; } } /* for(int i =1;i&lt;=5;++i){ cout &lt;&lt; dis[i] &lt;&lt; endl; } */ return 0;}","link":"/2019/07/09/并查集/"},{"title":"最小生成树","text":"CF1184E1 题目要求：可改变第一条边的权值，求出第一条边的最大权值，使得第一条边能在最小生成树内。分析：第一条边一定在最小生成树内，则第一条边两端点的连通性只能由这第一条边建立。除去第一条边进行建立最小生成树，当第一条边两端点连通时，即得到最大值，可以走第一条边，而不走当前边 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 7;#define debug(a) cout&lt;&lt;#a&lt;&lt;\": \"&lt;&lt;a&lt;&lt;'\\n'struct Edge{ ll x,y,val;}edge[maxn];int n,m;ll l = 0,r = 1e9 + 10,mid;bool cmp(Edge a,Edge b){ return a.val &lt; b.val ;}int head[maxn];int flag = 0;int _find(int x){ if(x == head[x])return x; else return head[x] = _find(head[x]);}void _union(int x,int y){ int hx = _find(x),hy = _find(y); if(hx == hy)return; head[hx] = hy;}int main(){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i =0;i &lt; m;++i){ cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].val; } sort(edge+1,edge+m,cmp); for(int i = 1;i &lt;= m;++i)head[i] = i; for(int i = 1;i &lt; m;++i){ if(_find(edge[i].x)!=_find(edge[i].y)){ head[_find(edge[i].x)] = _find(edge[i].y); if(_find(edge[0].x)==_find(edge[0].y)){ cout &lt;&lt; edge[i].val; return 0; } } } cout &lt;&lt; 1000000000; return 0;} CF1184E2紧接上题，对于任意的不在最小生成树上的边，修改这条边的权值，求解最大权值使该边能够在最小生成树上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 7;#define debug(a) cout&lt;&lt;#a&lt;&lt;\": \"&lt;&lt;a&lt;&lt;'\\n'struct Edge{ int x,y,val; int used,id;}edge[maxn];int fa[maxn],head[maxn],ver[3*maxn],nx[3*maxn],wei[3*maxn],tot;int root,dep[maxn],rt[maxn][20],dis[maxn],mx[maxn][20];ll ans[maxn];void add(int x,int y,int z){ ver[++tot] = y;wei[tot] = z; nx[tot] = head[x];head[x] = tot;}int _find(int x){ if(x == fa[x])return x; return fa[x] = _find(fa[x]); }bool cmp(Edge a,Edge b){ return a.val &lt; b.val;}void dfs(int x){ for(int i = head[x];i;i = nx[i]){ int y = ver[i]; if(dep[y])continue; dep[y] = dep[x] + 1; dis[y] = dis[x] + wei[i]; rt[y][0] = x; mx[y][0] = wei[i]; dfs(y); }}int lca(int u,int v){ if(dep[u] &gt; dep[v])swap(u,v); for(int i = 19;i &gt;= 0;--i){ if(dep[rt[v][i]] &gt;= dep[u])v = rt[v][i]; } /* for(int i = 0;i &lt; 20;++i){ if((dep[v] - dep[u]) &amp; (1 &lt;&lt; i))v = rt[v][i]; } */ if(u == v)return u; for(int i = 19;i &gt;= 0;--i) if(rt[u][i]!=rt[v][i])u = rt[u][i],v = rt[v][i]; return rt[u][0];}void lca_init(int n,int root){ dfs(root); for(int j = 1;j &lt; 20;++j){ for(int i = 1;i &lt;= n;++i){ rt[i][j] = rt[rt[i][j-1]][j-1]; mx[i][j] = max(mx[i][j-1],mx[rt[i][j-1]][j-1]); } }}int ask(int u,int cha){ int res = 0; for(int i = 0;i &lt; 20;++i) if(cha &amp; (1 &lt;&lt; i))res = max(res,mx[u][i]),u = rt[u][i]; return res;}int query(int x,int y){ int w = lca(x,y); int res = 0; res = max(ask(x,abs(dep[x]-dep[w])),ask(y,abs(dep[y]-dep[w]))); return res;}int main(){ ios::sync_with_stdio(false); int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= m;++i)cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].val,edge[i].id = i; for(int i = 1;i &lt;= n;++i)fa[i] = i; int cnt = 1; sort(edge + 1,edge + 1 + m,cmp); tot =0; for(int i = 1;i &lt;= m;++i){ int hx = _find(edge[i].x),hy = _find(edge[i].y); if(hx == hy)continue; else { fa[hx] = hy; add(hx,hy,edge[i].val); add(hy,hx,edge[i].val); edge[i].used = 1; ans[edge[i].id] = -1; } } root = 1; dep[1] = 1; dis[1] = 0; lca_init(n,root); for(int i = 1;i &lt;= m;++i){ if(!edge[i].used){ ans[edge[i].id] = query(edge[i].x,edge[i].y); } } for(int i = 1;i &lt;= m;++i){ if(ans[i]!=-1)cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;}","link":"/2019/09/10/最小生成树/"},{"title":"数据结构复习","text":"线性表的插入与删除广义表 长度，第一层的元素个数，空表长度为0，其它表长度为最大的那层括号中逗号数加一。 深度，转换成图形表示，相当于看二叉树深度，也可以看元素被多少层匹配的括号包裹，层数就等于对应深度。 森林与二叉树的转化基本知识： 树中度的定义：结点拥有的子树的个数。 二叉树是指度为2的有序树。 二叉树的特点方程，$n_0 = n_2 + 1，n_0为度为0的结点数，n_2是度为2的结点数$，再根据完全二叉树的性质，已知总结点个数可求得总度数和。 二叉链表存储二叉树，两个指针分别指向左右孩子。 二叉树从0开始编号，父节点i，左右子结点分别为2$\\ast$i+1,2$\\ast$i+2；从1开始编号，左右子结点分别为$2\\ast$$i$，$2\\ast$$i+1$. 森林转化成二叉树设森林F={$t_1$,$t_2$,$t_3$,$t_4$,…}，$t_i$分别表示树。形式定义：1.若F不为空，将$t_1$的根节点，作为二叉树的根节点。2.二叉树的左子树是从$t_1$的子树森林构造的。左子树的建立可以看作是在$t_1$的子树森林转换成二叉树。3.右子树是由原森林F减去$t_1$构造出来。右子树的建立可看作是由原森林减去第一棵树后的新森林转换成二叉树。 整体过程可以看成是递归向下进行的，关键在左子树由根节点对应的树的子树森林构成，右子树由除去根节点对应的森林构成。二叉树转换成森林，就是上述操作的逆过程图 完全图：所有结点之间都两两相连的图。内部排序 快速排序效率高，且空间占用小，但是是不稳定排序。 归并排序是稳定排序，但空间复杂度为O(n)，需要额外的空间。直接插入排序将元素插到对应位置，后面的元素都后移一位。希尔排序（缩小增量排序）先将序列分割成若干子序列，分别进行直接插入排序，待序列基本有序之后进行一次直接插入排序。增量大小对应子序列长度，初期能让元素“跳跃”移动。 选择排序长度为n的序列排序，以升序为例，第i轮从i到n找出最小的，记录位置为j，然后交换i，j的元素，i++。 插入排序与选择排序比较，插入排序变比变动，选择排序比完再动，插入排序比较次数相对少，但移动多，相反选择排序比较次数多，移动少，找出了就交换一位。要分清，我老是傻傻分不清，T^T。*冒泡排序不断维护最大或最小值，不断比较交换，冒泡到序列尾部。快速排序冒泡排序的改进，通过一次排序将待排序记录分割成两部分。方法： 1.将第一个元素作为参照，先保存下第一个元素，留到最后放到正确的位置。2.两个指针分别指向头和尾。3.后指针前移，找到找到第一个小于参照数，停下，或者与前指针重合停下，将后指针指向位置的数赋值给前指针的位置。4.前指针后移，直到找到第一个大于参照数，停下，或者与后指针重合停下，将前指针指向位置的数赋值给后指针的位置。5.如果前后指针重合，将参考值放在最后这个位置，递归由最终位置分割开的左右子段；如果没有重合回到第3步。快排练习,路过传送门，快排优化每次赋值之前都将原位置上的值转移了，所以赋值不会出问题。 快排空间复杂度$log_2（n）$，递归求解。 最小生成树Prim ，将一个点加入生成树，找出边最短，且零一点不在生成树上的边，然后将零一点加入生成树。kruskal ，找最短边，再判断两个点是否都在生成树中，都在就不取再找，否则选，将点加入生成树。 AOV网和拓扑排序AOV（Activity on vertex Network）顶点代表活动，弧表示活动间的优先关系。一定是有向无环图,AOV网中不能存在回路，让某个活动的开始要以自己完成作为先决条件，显然是不可以的。拓扑排序做法： 在有向图中选一个没有前驱的顶点并输出 删除该顶点及以该定点为尾的弧 回到最上面的操作，直至全部顶点输出或者当前图中不存在无前驱的顶点为止（后边的情况说明图中由有向环）。 解决哈希冲突的方法 开放定址法 $H_i=(H(key)+d_i)$ $MOD$ $m$ $i=1,2,…,k(k\\leq m-1)$$H(key)$为哈希函数；$m$为哈希表长；$d_i$为增量序列，有三种取法： 1.$d_i=1,2,3,…,m-1$，称线性探测再散列，碰到第一个未赋值的位置停下，赋值。2.$d_i=1^2,-1^2,2^2,-2^2,3^2,…,\\pm k^2(k\\leq m/2)$二次探测再散列，每次探测二次方的位置。3$$采用开放定址散列表处理冲突平均查找长度高于链地址法处理冲突。 二叉查找树，二叉平衡树二叉平衡树的实现回头再补上。","link":"/2019/06/25/数据结构复习/"},{"title":"模拟退火算法","text":"P1337 [JSOI2004]平衡点 / 吊打XXX洛谷题目传送门跟着大佬的博客学习。通常求最优解问题，贪心思路。模拟退火降温的过程，徐徐降温，让物体慢慢收缩，形成结晶，达到内能最低的状态。期间粒子从活跃地运动到逐渐稳定。这种方法不一定能找到最优解，提高温度的上限能更大概率的找到最优解主要参数： 温度：T 降温系数：D（每次以固定的比率降温） 温度下限：eps（到达温度下限就停止） 当前解：tx（若出现更优的结果，当前解更新，或者在一定接受度的情况下接受波动后的解） 最优解：当结果出现更优的情况时要更新最优解 解的变动值：$\\Delta$x(由当前温度T和一定的随机波动决定) 结果：目标（当有更好的结果时更新） 当前解的函数值与波动解的函数值之差：F（tx）-F（tx+$\\Delta$x） 接受度：$e^{(-(F(X_{new})-F(X_{old}))/T)}$接受度&gt;(long double)rand()/RAND_MAX，就接受新的变动后的解。 RAND_MAX是c中的宏定义，结果是随机数的最大值，（2rand（）-RAND_MAX）能得到[-RAND_MAX,RAND_MAX]范围内的全部结果。** 调参过程比较麻烦，之后多练习之后再来补充经验。不过需要注意模拟退火一般不是正解。","link":"/2019/06/28/模拟退火算法/"},{"title":"线性基","text":"对于线性基的解释可以参看大佬的博客，比较好理解，分析证明都比较好。 线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。 代码模板：线性基异或和最大数据范围（2^50）洛谷P3812 【模板】线性基 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5+5;ll a[55],d[55];void _insert(ll x){ //插入元素 for(int i =49;i&gt;=0;--i){ if(x&amp;(ll(1)&lt;&lt;i)){ //特别注意结果超出int范围，左移要加long long if(d[i])x^=d[i]; else{ d[i] = x; break; } } }}ll _query(){ //贪心求异或和最大 ll ans = 0; for(int i = 49;i&gt;=0;--i){ if((ans^d[i])&gt;ans)ans= (ans)^d[i]; //注意：异或结果比较时需要加上括号在进行比较，不然会出错 } return ans;}int main(){ ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for(int i = 1;i&lt;=n;++i)cin &gt;&gt; a[i],_insert(a[i]); cout &lt;&lt; _query(); return 0;}","link":"/2019/07/23/线性基/"},{"title":"最短路","text":"dijkstra思路：贪心 记录到起点的距离数组dis，初始化起点到起点距离为0，其他都设置为无穷大，后面再更新。设置标记数组f，标记即代表已经寻找到最短路。 标记起点，然后按照起点的出边更新起点到其他点的距离。 在距离矩阵中找最短的没有被标记的点，标记该点后，继续按照出边更新，直至全部顶点都被标记。 vis数组标记点是否已经达到最优解，根据贪心思想，每次出队时元素已经达到最优解，将该点标记。 优先队列维护的思想：优先队列（小根堆）维护各点到起点的距离，每次都找最近的未被标记的顶点，然后标记，更新。 spfa 迭代思想，不断更新。 vis数组记录当前点是否在队列里，保证队列里没有重复元素 slf优化* 求最短路时，将更新完的距离跟队列头的进行比较，比队首更小就放在队首，不然就放在队尾*","link":"/2019/07/10/最短路/"},{"title":"递推","text":"Yukina and ballDescription Yukina最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了NN个不同的球，想把它们放到MM个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上B站看游泳教练，于是他向你求助。 Input 多组数据，每行两个数N,M (1 \\le N, M \\le 20)N,M(1≤N,M≤20)。 Output 每组数据一行，表示方案数。 Sample Input 1 4 21 1Sample Output 1 7 1题解：设f[i][j]为前i个球放在前j个盒子里的方案数。将前i-1个球放在j个盒子里，再把第i个球放在任意一个盒子里 $jf[i-1][j]$将前i-1个球放在j-1个盒子里，把i单独放在一个新盒子里 $f[i-1][j-1]$递推式：$f[i][j] = jf[i-1][j] + f[i-1][j-1]$递推题老想不到，自己太笨了。","link":"/2019/07/20/递推/"},{"title":"编程的疑难","text":"程序突然卡住，不按照顺序执行，然后过了一会儿结束了，可能是开辟内存太多，爆了，程序提前结束。 结构体内不能开辟太多的空间，不然会爆。 main函数最后可以控制返回值，程序正常运行之后会得到预期的返回值，如果返回值不同说明程序提前结束（可能是运行时错误）了。 用define代替表达式时，记得运用时加上括号，编译器不会自动帮你计算结果后返回，所以不加括号在有乘法的时候可能会出错。","link":"/2019/07/02/编程的疑难/"},{"title":"高精度","text":"P1080 国王游戏 代码：写得头皮发麻，虽然不是最简单的版本，但是也算思路清晰，不同题目再相应处理就行。之后有更简洁的版本在更新。 123456789#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 5e2+5;/*加减乘除，处理放在外面也可以不用数组，用字符串每位模拟，最后返回字符串 */int a[MAXN],b[MAXN],c[MAXN]; //用两个数组存储每一位,a,b存数，c存结果 123456789101112131415161718192021222324void add(string s1,string s2){ //正整数数相加,输出的结果一定为正 memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); a[0] = s1.length(); //记录s1的长度 b[0] = s2.length(); //记录s2的长度 for(int i = 1;i&lt;=s1.length();++i)a[i] = s1[a[0]-i]-&apos;0&apos;; //将s1每一位转化成整数倒序放入a数组 for(int i = 1;i&lt;=s2.length();++i)b[i] = s2[b[0]-i]-&apos;0&apos;; //将每一位转化成整数倒序放入b数组 int len = max(a[0],b[0]); //去长度更大的 int cnt =0; //进位标志 for(int i = 1;i&lt;=len;++i){ //按位加法 c[i] = (a[i]+b[i]+cnt)%10; cnt = (a[i]+b[i]+cnt)/10; } if(cnt){ //最后还有进位的话，多添加一位 c[len+1] = 1; len++; } c[0] = len; for(int i = c[0];i&gt;=1;--i){ cout &lt;&lt; c[i] ; //按位输出; } cout &lt;&lt; endl;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int cmp(int a[],int b[]){ //高进度正整数比较 ,a&lt;b返回-1，a==b返回0，a&gt;b返回1 if(a[0]&lt;b[0])return -1; else if(a[0]&gt;b[0])return 1; else{ for(int i = a[0];i&gt;=1;--i){ //从高位比较到低位 if(a[i]&lt;b[i])return -1; else if(a[i]&gt;b[i])return 1; } return 0; }} /*减法注意运算后结果为0的高位应该忽略。 */void subtract(string s1,string s2){ //a-b 正整数相加减，结果可正可负 memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); int flag = 1,cnt =0; //记录符号位,借位符（低位是否需要借位） a[0] = s1.length();b[0] = s2.length(); for(int i = 1;i&lt;=s1.length();++i)a[i] = s1[a[0]-i] - &apos;0&apos;; for(int i = 1;i&lt;=s2.length();++i)b[i] = s2[b[0]-i] - &apos;0&apos;; if(cmp(a,b)==-1){ //如果 a小于b flag = -1; for(int i = 1;i&lt;=b[0];++i){ c[i] = b[i]-a[i]-cnt; cnt = 0; if(c[i]&lt;0){ c[i]+=10;cnt = 1; } } } else{ for(int i = 1;i&lt;=a[0];++i){ c[i] = a[i]-b[i]-cnt; cnt = 0; if(c[i]&lt;0){ c[i]+=10;cnt = 1; } } } if(flag == -1)cout &lt;&lt; &apos;-&apos;; int len = max(a[0],b[0]); //做减法时高位减小到0，则忽略 for(int i = len;i&gt;=1&amp;&amp;len&gt;1;--i) //len&gt;1,保证最少返回0 if(c[i]==0)len--; else break; c[0] = len; for(int i = c[0];i&gt;=1;--i)cout &lt;&lt; c[i]; cout &lt;&lt; endl;} 1234567891011121314151617181920212223242526void multi(string s1,string s2){ //正整数相乘 ，符号位在函数外处理 ，结果一定为正 int flag = 1; //记录结果是否为负数 //if(s1[0]==&apos;-&apos;)flag*=-1,s1.erase(0,1); //if(s2[0]==&apos;-&apos;)flag*=-1,s2.erase(0,1); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); a[0] = s1.length();b[0] = s2.length(); for(int i = 1;i&lt;=s1.length();++i)a[i] = s1[a[0]-i] - &apos;0&apos;; for(int i = 1;i&lt;=s2.length();++i)b[i] = s2[b[0]-i] - &apos;0&apos;; for(int i = 1;i&lt;=a[0];++i) for(int j = 1;j&lt;=b[0];++j) { c[i+j-1] += a[i]*b[j]; c[i+j] += c[i+j-1] / 10; c[i+j-1] %= 10; } if(flag == -1)cout &lt;&lt; &apos;-&apos;; int len = a[0] + b[0] + 1; //可能产生进位，从最高位前一位开始找结果的头。 while(c[len]==0&amp;&amp;len&gt;1)len--; //len&gt;1保证最后至少返回0 c[0] = len; for(int i = c[0];i&gt;=1;--i){ cout &lt;&lt; c[i] ; } cout &lt;&lt; endl;} 1234567891011121314151617181920void div1(string s1,ll s2){ //高精度正整数除以低精度正整数 ，符号在函数外判断，结果一定为正 memset(a,0,sizeof(a)); memset(c,0,sizeof(c)); a[0] = s1.length(); for(int i = 1;i &lt;= s1.length();++i)a[i] = s1[i-1] - &apos;0&apos;; ll tem = 0; //tem记录前一位剩下的部分的值 for(int i = 1;i&lt;=a[0];++i){ c[i] = (tem*10 + a[i])/s2; tem = (tem*10+a[i])%s2; } int l = 1,r = a[0]; //结果的左右边界； for(int i = l;i&lt;=r;++i){ if(c[i]!=0){ l = i; break; } } for(int i = l;i&lt;=r;++i)cout &lt;&lt; c[i]; cout &lt;&lt; endl;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void subduction(int a[],int b[]){ //a = a-b;此处的a。b数组中都还是倒序存储的 int flag = cmp(a,b); int i; if(flag == 0){ a[0] = 0;return ; //a被减完了 } if(flag == 1){ for(int i = 1;i&lt;=a[0];++i){ if(a[i]&lt;b[i]){ a[i+1]--; a[i] += 10; } a[i] -= b[i]; } while(a[0]&gt;0&amp;&amp;a[a[0]]==0)a[0]--; //消除前导零 return; }}void div2(string s1,string s2){ //正整数高精除以正整数高精 memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); a[0] = s1.length();b[0] = s2.length(); for(int i =1;i&lt;=a[0];++i)a[i] = s1[a[0]-i]-&apos;0&apos;; for(int i =1;i&lt;=b[0];++i)b[i] = s2[b[0]-i]-&apos;0&apos;; int tem[MAXN]; c[0] = a[0]-b[0]+1; for(int i = c[0];i&gt;=1;--i){ //i对应结果倒序的下标 memset(tem,0,sizeof(tem)); for(int j = 1;j&lt;=b[0];++j)tem[i+j-1] = b[j]; //倒序存储tem，从对应下标位置存储b，得到b的倍数与的当前的a进行比较 //for(int j = i+b[0]-1;j&gt;=1;--j)cout &lt;&lt; tem[j]; //cout &lt;&lt; endl; tem[0] = b[0]+ i-1; while(cmp(a,tem)&gt;=0){ //对应位上使用减法 c[i]++; subduction(a,tem); } } while(c[0]&gt;0&amp;&amp;c[c[0]]==0)c[0]--; //去除前导零 cout &lt;&lt; &quot;商为:&quot;; if(c[0]==0){ cout &lt;&lt; 0 &lt;&lt; endl; return ; } else { for(int i = c[0];i&gt;=1;--i){ cout &lt;&lt; c[i]; } } cout &lt;&lt; &quot;余数为；&quot;; if(a[0]==0){ cout &lt;&lt; 0 &lt;&lt;endl; } else { for(int i = a[0];i&gt;=1;--i){ cout &lt;&lt; a[i] ; } cout &lt;&lt; endl; }} 1234int main(){ ios::sync_with_stdio(false); return 0;}","link":"/2019/07/14/高精度/"},{"title":"软件工程","text":"例题填空题1.按软件的功能进行划分，软件可划分为系统软件、支撑软件、应用软件。 2.软件生命周期由软件定义、软件开发和运行维护3个时期。每个时期又可进一步划分为若干阶段。其中，软件开发时期由总体设计、详细设计、编码和单元测试和综合测试4个阶段构成。3.在可行性研究阶段，分析员要从技术可行性、经济可行性和操作可行性等方面来研究每种解决方案的可行性。4.内聚标志着一个模块内部每个元素彼此结合的紧密程度，耦合是对一个软件结构内不同模块之间互联程度的度量。5.面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法，因此，设计的过程就有了基于变换流的分析方法和基于事务流的分析方法两种。6.软件体系结构通常可以看作是三个要素构成的，这三个要素分别是构件、连接件和约束。 这三个是最基本要素，网上参考核心的五个要素是：构件、连接件、配置、端口和角色7.结构化方法有结构化分析、结构化设计、结构化程序设计它是一种面向数据流的开发方法。结构化方法由jiegouhua 8.决定软件的可维护性的5个主要因素分别是：可理解性、可测试性、可修改性、可移植性、可重用性。 9.在UML图中描述一个对象的生命周期的图是状态图10.在类图中，可见性包括公有的、私有的、保护的。 11.程序的三种基本控制结构是顺序、选择、循环。 判断题（F）1.软件的维护成本通常比开发成本低。软件生命周期中所花费用最多的阶段是软件维护s（T）2.HIPO法既是需求分析方法，又是软件设计方法。（F）3.数据流图中需要描绘出数据流出现的条件。DFD应该描绘所有可能的数据流向，而不应该描绘出现某个数据流的条件。（T）4.用户界面设计对系统的成功至关重要，一个设计的很差的用户界面可能会导致用户拒绝使用该系统。（F）5.逻辑覆盖测试中，满足条件覆盖的测试案例同时也满足判定覆盖。 不一定（F）6.结构图是精确表达程序结构的图形表示法。因此，有时也可以将系统的结构图当作系统流程图使用。 来自网络 系统流程图：反映主体框架；系统结构图：反映的是系统中模块的调用关系和层次关系,谁调用谁,有一个先后次序(时序)关系。两种图作用不同，不能互用（F）7.状态图是UML中系统的静态方面进行建模的图之一。 来自PPT 静态建模有四种：用例图、类图、对象图、包图；动态建模有五种：消息、顺序图、协作图、活动图、状态图。 （T）8.顺序图由角色、对象、生命线、激活和消息组成。（F）9.在等价类测试方法中，为了提高测试效率，一个测试用例可以覆盖多个无效等价类。(T)10.在软件的生存周期中，工作量所占的比最大的阶段就是维护阶段。(T)11.通过功能分解可以完成数据流图的细化(F)12.当验收测试通过，软件开发就完成了。–答案源自南昌大学期末卷多次出现，但是有疑惑，不知道原因（T）13在模块化设计中，模块越小，模块的有点越明显。一般来说，模块的大小都在10行以下。 问答题1.请简要介绍一下软件工程的7个方面的本质特性书上P6 2.简单论述软件体系结构的概念具体见软件体系结构的PPT。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;体系结构是软件的总体框架，描述了软件系统的系统组织方式，包括构成系统的构件接口、行为模式、协作关系以及对这些问题的决策等信息；体系结构不仅设计到结构与行为，而且还涉及到系统的使用、功能、性能、适应性、重用性、可理解性、经济性和技术约束的均衡；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件体系结构是针对软件系统的规模和复杂性进行系统全局结构的设计和规划，包括全局组织结构；全局控制结构；通信和同步以及数据存取的协议；规定设计元素的功能；设计元素的组合；物理分布；规模和性能；演绎的维度；设计方案的选择等。3.在设计黑盒测试方案时，应该考虑哪些方面的问题？书P171-P1724.请简单比较一下自顶向下和自底向上集成测试策略。书P157-1595.UML中协作图和顺序图的区别是什么？（以下来自网络）时序图主要侧重于对象间消息传递在时间上的先后关系, 而协作图表达对象间的交互过程及对象间的关联关系，或者说为空间上的关系。其余部分见两者定义再分析 分析简答题1.根据以下条件，试画出某高校财务系统中计算机教工出差补助的 判定表出差补助政策如下：a）如果教工已经办理长期出差手续，则无论出差到哪里，出差补助都是每天80元b）如果教工没有办理出差手续，则出差到一线城市，每天补助150元；出差到其他城市，每天补助100元；出差到偏远地区，每天补助300元。c）如果教工本月未出差，无论是否办理长期出差手续，都没有出差补助。 2.银行计算机储蓄系统的工作过程大致如下：储户填写的存款单或取款单有业务员键入系统，如果是存款则系统记录存款人姓名，住址（或电话号码）、身份证号码、存款类型、存款日期、到期日期、利率及密码（可选）等信息，并印出存单给储户：如果是取款而且存款对象留有密码，则系统首先核对储户密码，或密码正确或存款时为留密码，则系统计算利息并印出利息清单给储户。请用数据流图描绘本系统的功能。 可行性研究时的图系统流程图系统流程图时概括地描绘物理系统的传统工具，基本思想是用图形符号以黑盒子的形式描绘组成系统的每个部件（程序、文档、数据库、人工过程等）。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，因此尽管系统流程图的某系符号和程序流程图的符号形式相同，但是它确是物理数据流图而不是程序流程图。 需求分析时的图1.层次方框图（P68）：树形结构的的一系列多层次的矩形框描绘数据的层次结构，顶层单独的矩形框代表完整的数据结构，下面各层的矩形框代表数据的子集，最底层为不可再分割的元素。2.IPO图（P69）：描绘输入数据、对数据的处理和输出数据之间的关系。 总体设计时的图层次图1.层次图（P102），描绘模型层次结构，矩形框代表一个模块，方框的连线代表调用关系而不像层次方框图那样表示组成关系。层次图很适合自顶向下设计软件的过程中使用 HIPO图2.HIPO图（P103）：层次图加IPO，方框带上编号，每个方框对应一张IPO图描绘这个方框代表的模块的处理过程。 结构图（SC图）3.结构图（P103）：描绘软件结构，方框代表一个模块，框内注明模块的名字或主要功能；方框之间的箭头（或直线）表示模块之间的调用关系。箭头尾部是空心圆表示传递的是数据，尾部是实心圆表示传递的是控制信息。 详细设计时的图程序流程图盒图（NS图）PAD图（Problem Analysis Diagram）过程设计语言（PDL）UML（Unified Modeling Language） 功能模型：从用户的角度展示系统的功能，包括用例图 对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类图、对象图。 动态模型：展现系统的内部行为。包括序列图，活动图，状态图。 UML图，包括用例图、协作图、活动图、序列图、部署图、构件图、类图、对象图、状态图，是模型中信息的图形表达方式，但是UML模型独立于UML图存在。 物理架构构件图配置图逻辑架构动态建模动态建模：用来展示系统的行为1.时序图：描述对象的交互过程.以时间为参考(强调的是时间顺序). 虚线：(生命线)表示对象的生命周期. 实线：对象消息. 虚线：返回消息. 长方形：活动(激活). 叉：对象消亡.2.协作图：跟时序图一样,但强调对象的连接关系.3.状态图：描述对象的自身的状态(一个对象的类型不同可能行为很古怪,行为变化很大).4.活动图：(类似于流程图)描述一个环境中的交互顺序. 时序图顺序图（sequence diagram） 描述对象间交互关系。对象用矩形框表示，框内标对象名；矩形框下的竖线代表对象的生命线；对象生命线上的细长矩形框表示对象被激活；对象间通信用对象间水平消息线表示，箭头形状表明消息类型（同步、异步或简单）。 协作图协作图（Collaboration diagram） 描述相互协作对象间交互关系和链接关系。顺序图着重表现交互时间顺序；协作图着重表现交互对象的静态链接消息；协作图显示对象间处理过程的分布 活动图活动图（Activity diagram）描述为完成某一个用例需要做的活动以及这些活动的执行顺序。活动图由状态图变化而来，各自用于不同目的。状态图着重描述对象的状态变化以及触发状态变化的事件。活动图着重描述各种活动的执行顺序。 状态图状态图：也即状态转换图，通过描述系统的状态及引起系统状态转换的事件来表示系统的行为，还指明了作为特定时间的结果系统将做哪些动作（例如处理数据）。状态图既可以表示循环运行过程，也可以表示系统单程生命期。 静态建模静态建模：创建并建立一个系统的静态特征 1.用例图：描述系统功能及功能的使用者.2.类 图：表现系统里实体的关系,责任,类和类之间的关系，属性及方法.3.对象图：当类图不能完全显示关系时用对象图.描述对象的属性,对象名,方法.4.组件图：对类功能的封装,一个组件包含多个类. 虚线：表示依赖关系.5.部署图：描述系统中的物理结构. 实线：表示连接 类图对象图包图","link":"/2020/01/08/软件工程/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"软件工程","slug":"软件工程","link":"/tags/软件工程/"}],"categories":[]}