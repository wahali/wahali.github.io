{"pages":[],"posts":[{"title":"模拟退火算法","text":"通常求最优解问题,贪心思路 主要参数： 温度：T 降温系数：D（每次以固定的比率降温） 温度下限：eps（到达温度下限就停止） 当前解：tx（若出现更优的结果，当前解更新，或者在一定接受度的情况下接受波动后的解） 最优解：当结果出现更优的情况时要更新最优解 解的变动值：$\\Delta$x(由当前温度T和一定的随机波动决定) 结果：目标（当有更好的结果时更新） 当前解的函数值与波动解的函数值之差：F（tx）-F（tx+$\\Delta$x） 接受度：$e^{(-(F(X_{new})-F(X_{old}))/T)}$&gt;(long double)rand()/RAND_MAX 就接受","link":"/2019/06/28/模拟退火算法/"},{"title":"编程的疑难","text":"程序突然卡住，不按照顺序执行，然后过了一会儿结束了，可能是开辟内存太多，爆了，程序提前结束。 结构体内不能开辟太多的空间，不然会爆。 main函数最后可以控制返回值，程序正常运行之后会得到预期的返回值，如果返回值不同说明程序提前结束（可能是运行时错误）了。","link":"/2019/07/02/编程的疑难/"},{"title":"数据结构复习","text":"线性表的插入与删除广义表 长度，第一层的元素个数，空表长度为0，其它表长度为最大的那层括号中逗号数加一。 深度，转换成图形表示，相当于看二叉树深度，也可以看元素被多少层匹配的括号包裹，层数就等于对应深度。 森林与二叉树的转化基本知识： 树中度的定义：结点拥有的子树的个数。 二叉树是指度为2的有序树。 二叉树的特点方程，$n_0 = n_2 + 1，n_0为度为0的结点数，n_2是度为2的结点数$，再根据完全二叉树的性质，已知总结点个数可求得总度数和。 二叉链表存储二叉树，两个指针分别指向左右孩子。 二叉树从0开始编号，父节点i，左右子结点分别为2$\\ast$i+1,2$\\ast$i+2；从1开始编号，左右子结点分别为2$\\ast$i，2$\\ast$i+1. 森林转化成二叉树设森林F={$t_1$,$t_2$,$t_3$,$t_4$,…}，$t_i$分别表示树。形式定义：1.若F不为空，将$t_1$的根节点，作为二叉树的根节点。2.二叉树的左子树是从$t_1$的子树森林构造的。左子树的建立可以看作是在$t_1$的子树森林转换成二叉树。3.右子树是由原森林F减去$t_1$构造出来。右子树的建立可看作是由原森林减去第一棵树后的新森林转换成二叉树。 整体过程可以看成是递归向下进行的，关键在左子树由根节点对应的树的子树森林构成，右子树由除去根节点对应的森林构成。二叉树转换成森林，就是上述操作的逆过程图 完全图：所有结点之间都两两相连的图。 内部排序 快速排序效率高，且空间占用小，但是是不稳定排序。 归并排序是稳定排序，但空间复杂度为O(n)，需要额外的空间。直接插入排序将元素插到对应位置，后面的元素都后移一位。希尔排序（缩小增量排序）先将序列分割成若干子序列，分别进行直接插入排序，待序列基本有序之后进行一次直接插入排序。增量大小对应子序列长度，初期能让元素“跳跃”移动。 选择排序长度为n的序列排序，以升序为例，第i轮从i到n找出最小的，记录位置为j，然后交换i，j的元素，i++。 插入排序与选择排序比较，插入排序变比变动，选择排序比完再动，插入排序比较次数相对少，但移动多，相反选择排序比较次数多，移动少，找出了就交换一位。要分清，我老是傻傻分不清，T^T。*冒泡排序不断维护最大或最小值，不断比较交换，冒泡到序列尾部。快速排序冒泡排序的改进，通过一次排序将待排序记录分割成两部分。方法： 1.将第一个元素作为参照，先保存下第一个元素，留到最后放到正确的位置。2.两个指针分别指向头和尾。3.后指针前移，找到找到第一个小于参照数，停下，或者与前指针重合停下，将后指针指向位置的数赋值给前指针的位置。4.前指针后移，直到找到第一个大于参照数，停下，或者与后指针重合停下，将前指针指向位置的数赋值给后指针的位置。5.如果前后指针重合，将参考值放在最后这个位置，递归由最终位置分割开的左右子段；如果没有重合回到第3步。每次赋值之前都将原位置上的值转移了，所以赋值不会出问题。 快排空间复杂度$log_2（n）$，递归求解。 最小生成树Prim ，将一个点加入生成树，找出边最短，且零一点不在生成树上的边，然后将零一点加入生成树。kruskal ，找最短边，再判断两个点是否都在生成树中，都在就不取再找，否则选，将点加入生成树。 AOV网和拓扑排序AOV（Activity on vertex Network）顶点代表活动，弧表示活动间的优先关系。一定是有向无环图,AOV网中不能存在回路，让某个活动的开始要以自己完成作为先决条件，显然是不可以的。拓扑排序做法： 在有向图中选一个没有前驱的顶点并输出 删除该顶点及以该定点为尾的弧 回到最上面的操作，直至全部顶点输出或者当前图中不存在无前驱的顶点为止（后边的情况说明图中由有向环）。 解决哈希冲突的方法 开放定址法 $H_i=(H(key)+d_i)$ $MOD$ $m$ $i=1,2,…,k(k\\leq m-1)$$H(key)$为哈希函数；$m$为哈希表长；$d_i$为增量序列，有三种取法： 1.$d_i=1,2,3,…,m-1$，称线性探测再散列，碰到第一个未赋值的位置停下，赋值。2.$d_i=1^2,-1^2,2^2,-2^2,3^2,…,\\pm k^2(k\\leq m/2)$二次探测再散列，每次探测二次方的位置。3$$采用开放定址散列表处理冲突平均查找长度高于链地址法处理冲突。 二叉查找树，二叉平衡树二叉平衡树的实现回头再补上。","link":"/2019/06/25/数据结构复习/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/25/hello-world/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/算法/"}],"categories":[]}