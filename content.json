{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/25/hello-world/"},{"title":"数据结构复习","text":"线性表的插入与删除森林与二叉树的转化森林转化成二叉树设森林F={$t_1$,$t_2$,$t_3$,$t_4$,…}，$t_i$分别表示树。形式定义：1.若F不为空，将$t_1$的根节点，作为二叉树的根节点。2.二叉树的左子树是从$t_1$的子树森林构造的。左子树的建立可以看作是在$t_1$的子树森林转换成二叉树。3.右子树是由原森林F减去$t_1$构造出来。右子树的建立可看作是由原森林减去第一棵树后的新森林转换成二叉树。 整体过程可以看成是递归向下进行的，关键在左子树由根节点对应的树的子树森林构成，右子树由除去根节点对应的森林构成。二叉树转换成森林，就是上述操作的逆过程 内部排序直接插入排序将元素插到对应位置，后面的元素都后移一位。 希尔排序（缩小增量排序）先将序列分割成若干子序列，分别进行直接插入排序，待序列基本有序之后进行一次直接插入排序。增量大小对应子序列长度，初期能让元素“跳跃”移动。 选择排序长度为n的序列排序，以升序为例，第i轮从i到n找出最小的，记录位置为j，然后交换i，j的元素，i++。插入排序与选择排序比较，插入排序变比变动，选择排序比完再动，插入排序比较次数相对少，但移动多，相反选择排序比较次数多，移动少，找出了就交换一位。要分清，我老是傻傻分不清，T^T。 冒泡排序不断维护最大或最小值，不断比较交换，冒泡到序列尾部。 快速排序冒泡排序的改进，通过一次排序将待排序记录分割成两部分。方法：1.将第一个元素作为参照，先保存下第一个元素，留到最后放到正确的位置。2.两个指针分别指向头和尾。3.后指针前移，找到找到第一个小于参照数，停下，或者与前指针重合停下，将后指针指向位置的数赋值给前指针的位置。4.前指针后移，直到找到第一个大于参照数，停下，或者与后指针重合停下，将前指针指向位置的数赋值给后指针的位置。5.如果前后指针重合，将参考值放在最后这个位置，递归由最终位置分割开的左右子段；如果没有重合回到第3步。每次赋值之前都将原位置上的值转移了，所以赋值不会出问题。 最小生成树Prim ，将一个点加入生成树，找出边最短，且零一点不在生成树上的边，然后将零一点加入生成树。kruskal ，找最短边，再判断两个点是否都在生成树中，都在就不取再找，否则选，将点加入生成树。 解决哈希冲突的方法二叉查找树，二叉平衡树二叉平衡树的实现回头再补上。","link":"/2019/06/25/数据结构复习/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/算法/"}],"categories":[]}