<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>peterpan的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.peterpan666.com/"/>
  <updated>2019-07-04T04:04:13.909Z</updated>
  <id>https://www.peterpan666.com/</id>
  
  <author>
    <name>Peter_Pan_666</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分图</title>
    <link href="https://www.peterpan666.com/2019/07/04/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://www.peterpan666.com/2019/07/04/二分图/</id>
    <published>2019-07-04T03:13:03.000Z</published>
    <updated>2019-07-04T04:04:13.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>无向图G的二分图的充分必要条件：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G至少有两个点；对于G中每条回路长度得是偶数。</span><br></pre></td></tr></table></figure><p>匹配</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于G的一个子图M，M的边集中任何两条边都不依附于同一个点，则称这个边集是一个匹配，匹配的数量由边数决定。(可以理解左右两堆点，一一匹配，左边的点只能跟右边的一个点匹配)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;无向图G的二分图的充分必要条件：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu</title>
    <link href="https://www.peterpan666.com/2019/07/03/Ubuntu/"/>
    <id>https://www.peterpan666.com/2019/07/03/Ubuntu/</id>
    <published>2019-07-03T03:00:50.000Z</published>
    <updated>2019-07-03T08:49:33.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ubuntu-安装在vmware上"><a href="#Ubuntu-安装在VMware上" class="headerlink" title="Ubuntu 安装在VMware上"></a>Ubuntu 安装在VMware上</h2><p>笔记本安装遇到的分辨率和刷新率的问题，先使用设置中调整分辨率再进行安装</p><h4 id="vmware-tool文件复制到桌面之后再提取到主目录不然会报错"><a href="#VMware-Tool文件复制到桌面之后再提取到主目录，不然会报错" class="headerlink" title="VMware Tool文件复制到桌面之后再提取到主目录，不然会报错"></a>VMware Tool文件复制到桌面之后再提取到主目录，不然会报错</h4><h4 id="共享文件夹老挂载不上"><a href="#共享文件夹老挂载不上，" class="headerlink" title="共享文件夹老挂载不上，"></a>共享文件夹老挂载不上，</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ubuntu-安装在vmware上&quot;&gt;&lt;a href=&quot;#Ubuntu-安装在VMware上&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 安装在VMware上&quot;&gt;&lt;/a&gt;Ubuntu 安装在VMware上&lt;/h2&gt;&lt;p&gt;笔记本安装遇到的分辨
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iracus主题个性化配置</title>
    <link href="https://www.peterpan666.com/2019/07/02/iracus%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.peterpan666.com/2019/07/02/iracus主题个性化配置/</id>
    <published>2019-07-02T15:45:17.000Z</published>
    <updated>2019-07-04T06:21:51.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="201973-站点无法访问重定向太多了过了一段时间又好了可能配置之后dns没有及时更新导致的"><a href="#2019-7-3-站点无法访问，重定向太多了，过了一段时间又好了，可能配置之后DNS没有及时更新导致的。" class="headerlink" title="2019/7/3 站点无法访问，重定向太多了，过了一段时间又好了，可能配置之后DNS没有及时更新导致的。"></a>2019/7/3 站点无法访问，重定向太多了，过了一段时间又好了，可能配置之后DNS没有及时更新导致的。</h3><h3 id="谷歌收录挺快的百度收录通过cname方式验证了网站可算验证成功了"><a href="#谷歌收录挺快的，百度收录通过CNAME方式验证了网站，可算验证成功了。" class="headerlink" title="谷歌收录挺快的，百度收录通过CNAME方式验证了网站，可算验证成功了。"></a>谷歌收录挺快的，百度收录通过CNAME方式验证了网站，可算验证成功了。</h3><h3 id="尝试修复toc锚点即目录无法跳转的问题"><a href="#尝试修复toc锚点，即目录无法跳转的问题" class="headerlink" title="尝试修复toc锚点，即目录无法跳转的问题"></a>尝试修复toc锚点，即目录无法跳转的问题</h3><p>参看<a href="https://convivae.top/2019/03/29/Hexo%20博客踩坑/#toc-锚点-undefined" target="_blank" rel="noopener">帮助</a>，由于我没有对应的文件，我未采用方法1，采用方法2保留到了原版本，解决了该问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;201973-站点无法访问重定向太多了过了一段时间又好了可能配置之后dns没有及时更新导致的&quot;&gt;&lt;a href=&quot;#2019-7-3-站点无法访问，重定向太多了，过了一段时间又好了，可能配置之后DNS没有及时更新导致的。&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编程的疑难</title>
    <link href="https://www.peterpan666.com/2019/07/02/%E7%BC%96%E7%A8%8B%E7%9A%84%E7%96%91%E9%9A%BE/"/>
    <id>https://www.peterpan666.com/2019/07/02/编程的疑难/</id>
    <published>2019-07-02T07:58:17.000Z</published>
    <updated>2019-07-04T02:38:15.348Z</updated>
    
    <content type="html"><![CDATA[<ul><li>程序突然卡住，不按照顺序执行，然后过了一会儿结束了，可能是开辟内存太多，爆了，程序提前结束。</li><li>结构体内不能开辟太多的空间，不然会爆。</li><li>main函数最后可以控制返回值，程序正常运行之后会得到预期的返回值，如果返回值不同说明程序提前结束（可能是运行时错误）了。</li><li>用define代替表达式时，记得运用时加上括号，编译器不会自动帮你计算结果后返回，所以不加括号在有乘法的时候可能会出错。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;程序突然卡住，不按照顺序执行，然后过了一会儿结束了，可能是开辟内存太多，爆了，程序提前结束。&lt;/li&gt;
&lt;li&gt;结构体内不能开辟太多的空间，不然会爆。&lt;/li&gt;
&lt;li&gt;main函数最后可以控制返回值，程序正常运行之后会得到预期的返回值，如果返回值不同说明程序提
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="https://www.peterpan666.com/2019/06/28/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <id>https://www.peterpan666.com/2019/06/28/模拟退火算法/</id>
    <published>2019-06-28T15:20:28.000Z</published>
    <updated>2019-07-04T03:13:24.700Z</updated>
    
    <content type="html"><![CDATA[<p><strong>P1337 [JSOI2004]平衡点 / 吊打XXX</strong><br><a href="https://www.luogu.org/problemnew/show/P1337" target="_blank" rel="noopener"><strong>洛谷题目传送门</strong></a><br><strong>跟着<a href="https://www.cnblogs.com/flashhu/category/1202079.html" target="_blank" rel="noopener">大佬的博客</a>学习。</strong><br><em>通常求最优解问题，贪心思路。</em><br>模拟退火降温的过程，徐徐降温，让物体慢慢收缩，形成结晶，达到内能最低的状态。期间粒子从活跃地运动到逐渐稳定。<br><strong>这种方法不一定能找到最优解，提高温度的上限能更大概率的找到最优解</strong><br>主要参数：</p><ul><li>温度：T</li><li>降温系数：D（每次以固定的比率降温）</li><li>温度下限：eps（到达温度下限就停止）</li><li>当前解：tx（若出现更优的结果，当前解更新，或者在一定接受度的情况下接受波动后的解）</li><li>最优解：当结果出现更优的情况时要更新最优解</li><li>解的变动值：$\Delta$x(由当前温度T和一定的随机波动决定)</li><li>结果：目标（当有更好的结果时更新）</li><li>当前解的函数值与波动解的函数值之差：F（tx）-F（tx+$\Delta$x）</li><li>接受度：<br>$e^{(-(F(X_{new})-F(X_{old}))/T)}$接受度&gt;(long double)rand()/RAND_MAX，就接受新的变动后的解。  </li><li><em>RAND_MAX是c中的宏定义，结果是随机数的最大值，（2</em>rand（）-RAND_MAX）能得到[-RAND_MAX,RAND_MAX]范围内的全部结果。**</li></ul><p>调参过程比较麻烦，之后多练习之后再来补充经验。不过需要注意模拟退火一般不是正解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;P1337 [JSOI2004]平衡点 / 吊打XXX&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1337&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构复习</title>
    <link href="https://www.peterpan666.com/2019/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.peterpan666.com/2019/06/25/数据结构复习/</id>
    <published>2019-06-25T08:42:02.000Z</published>
    <updated>2019-07-02T15:54:22.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表的插入与删除"><a href="#线性表的插入与删除" class="headerlink" title="线性表的插入与删除"></a>线性表的插入与删除</h2><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><ul><li>长度，第一层的元素个数，空表长度为0，其它表长度为最大的那层括号中逗号数加一。  </li><li>深度，转换成图形表示，相当于看二叉树深度，也可以看元素被多少层匹配的括号包裹，层数就等于对应深度。<a id="more"></a><h2 id="森林与二叉树的转化"><a href="#森林与二叉树的转化" class="headerlink" title="森林与二叉树的转化"></a>森林与二叉树的转化</h2>基本知识：  </li><li>树中度的定义：结点拥有的子树的个数。  </li><li>二叉树是指度为2的有序树。</li><li>二叉树的特点方程，$n_0 = n_2 + 1，n_0为度为0的结点数，n_2是度为2的结点数$，再根据完全二叉树的性质，已知总结点个数可求得总度数和。  </li><li>二叉链表存储二叉树，两个指针分别指向左右孩子。</li><li>二叉树从0开始编号，父节点i，左右子结点分别为2$\ast$i+1,2$\ast$i+2；从1开始编号，左右子结点分别为2$\ast$i，2$\ast$i+1.</li></ul><h4 id="森林转化成二叉树"><a href="#森林转化成二叉树" class="headerlink" title="森林转化成二叉树"></a>森林转化成二叉树</h4><h5 id="设森林ft_1t_2t_3t_4t_i分别表示树"><a href="#设森林F-t-1-t-2-t-3-t-4-…-，-t-i-分别表示树。" class="headerlink" title="设森林F={$t_1$,$t_2$,$t_3$,$t_4$,…}，$t_i$分别表示树。"></a>设森林F={$t_1$,$t_2$,$t_3$,$t_4$,…}，$t_i$分别表示树。</h5><p>形式定义：<br>1.若F不为空，将$t_1$的根节点，作为二叉树的根节点。<br>2.二叉树的左子树是从$t_1$的子树森林构造的。左子树的建立可以看作是在$t_1$的子树森林转换成二叉树。<br>3.右子树是由原森林F减去$t_1$构造出来。右子树的建立可看作是由原森林减去第一棵树后的新森林转换成二叉树。  </p><h5 id="整体过程可以看成是递归向下进行的关键在左子树由根节点对应的树的子树森林构成右子树由除去根节点对应的森林构成"><a href="#整体过程可以看成是递归向下进行的，关键在左子树由根节点对应的树的子树森林构成，右子树由除去根节点对应的森林构成。" class="headerlink" title="整体过程可以看成是递归向下进行的，关键在左子树由根节点对应的树的子树森林构成，右子树由除去根节点对应的森林构成。"></a><strong><em>整体过程可以看成是递归向下进行的，关键在左子树由根节点对应的树的子树森林构成，右子树由除去根节点对应的森林构成。</em></strong></h5><h4 id="二叉树转换成森林就是上述操作的逆过程"><a href="#二叉树转换成森林，就是上述操作的逆过程" class="headerlink" title="二叉树转换成森林，就是上述操作的逆过程"></a>二叉树转换成森林，就是上述操作的逆过程</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul><li>完全图：所有结点之间都两两相连的图。<h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2></li><li>快速排序效率高，且空间占用小，但是是不稳定排序。  </li><li>归并排序是稳定排序，但空间复杂度为O(n)，需要额外的空间。<br><img src="https://i.loli.net/2019/06/26/5d1369e86dc5282516.png" alt><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3>将元素插到对应位置，后面的元素都后移一位。<h3 id="希尔排序缩小增量排序"><a href="#希尔排序（缩小增量排序）" class="headerlink" title="希尔排序（缩小增量排序）"></a>希尔排序（缩小增量排序）</h3>先将序列分割成若干子序列，分别进行直接插入排序，待序列基本有序之后进行一次直接插入排序。<br>增量大小对应子序列长度，初期能让元素“跳跃”移动。  <h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>长度为n的序列排序，以升序为例，第i轮从i到n找出最小的，记录位置为j，然后交换i，j的元素，i++。  </li><li><strong>插入排序与选择排序比较，插入排序变比变动，选择排序比完再动，插入排序比较次数相对少，但移动多，相反选择排序比较次数多，移动少，找出了就交换一位。要分清，我老是傻傻分不清，T^T。*</strong><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3>不断维护最大或最小值，不断比较交换，冒泡到序列尾部。<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3>冒泡排序的改进，通过一次排序将待排序记录分割成两部分。<br>方法：  </li></ul><p>1.将第一个元素作为参照，先保存下第一个元素，留到最后放到正确的位置。<br>2.两个指针分别指向头和尾。<br>3.后指针前移，找到找到第一个小于参照数，停下，或者与前指针重合停下，将后指针指向位置的数赋值给前指针的位置。<br>4.前指针后移，直到找到第一个大于参照数，停下，或者与后指针重合停下，将前指针指向位置的数赋值给后指针的位置。<br>5.如果前后指针重合，将参考值放在最后这个位置，递归由最终位置分割开的左右子段；如果没有重合回到第3步。<br><strong>每次赋值之前都将原位置上的值转移了，所以赋值不会出问题。</strong></p><ul><li>快排空间复杂度$log_2（n）$，递归求解。</li></ul><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>Prim ，将一个点加入生成树，找出边最短，且零一点不在生成树上的边，然后将零一点加入生成树。<br>kruskal ，找最短边，再判断两个点是否都在生成树中，都在就不取再找，否则选，将点加入生成树。</p><h2 id="aov网和拓扑排序"><a href="#AOV网和拓扑排序" class="headerlink" title="AOV网和拓扑排序"></a>AOV网和拓扑排序</h2><p>AOV（Activity on vertex Network）顶点代表活动，弧表示活动间的优先关系。一定是<strong>有向无环图</strong>,<em>AOV网中不能存在回路，让某个活动的开始要以自己完成作为先决条件，显然是不可以的。</em><br>拓扑排序做法：  </p><ul><li>在有向图中选一个没有前驱的顶点并输出  </li><li>删除该顶点及以该定点为尾的弧  </li><li>回到最上面的操作，直至全部顶点输出或者当前图中不存在无前驱的顶点为止（后边的情况说明图中由有向环）。</li></ul><h2 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h2><ul><li>开放定址法  $H_i=(H(key)+d_i)$ $MOD$ $m$  $i=1,2,…,k(k\leq m-1)$<br>$H(key)$为哈希函数；$m$为哈希表长；$d_i$为增量序列，有三种取法：  </li></ul><p>1.$d_i=1,2,3,…,m-1$，称线性探测再散列，碰到第一个未赋值的位置停下，赋值。<br>2.$d_i=1^2,-1^2,2^2,-2^2,3^2,…,\pm k^2(k\leq m/2)$二次探测再散列，每次探测二次方的位置。<br>3$$<br><strong>采用开放定址散列表处理冲突平均查找长度高于链地址法处理冲突。</strong></p><h2 id="二叉查找树二叉平衡树"><a href="#二叉查找树，二叉平衡树" class="headerlink" title="二叉查找树，二叉平衡树"></a>二叉查找树，二叉平衡树</h2><p>二叉平衡树的实现回头再补上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性表的插入与删除&quot;&gt;&lt;a href=&quot;#线性表的插入与删除&quot; class=&quot;headerlink&quot; title=&quot;线性表的插入与删除&quot;&gt;&lt;/a&gt;线性表的插入与删除&lt;/h2&gt;&lt;h2 id=&quot;广义表&quot;&gt;&lt;a href=&quot;#广义表&quot; class=&quot;headerlink&quot; title=&quot;广义表&quot;&gt;&lt;/a&gt;广义表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;长度，第一层的元素个数，空表长度为0，其它表长度为最大的那层括号中逗号数加一。  &lt;/li&gt;
&lt;li&gt;深度，转换成图形表示，相当于看二叉树深度，也可以看元素被多少层匹配的括号包裹，层数就等于对应深度。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.peterpan666.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
