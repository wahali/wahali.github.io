<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>peterpan的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.peterpan666.com/"/>
  <updated>2020-01-16T04:25:00.810Z</updated>
  <id>https://www.peterpan666.com/</id>
  
  <author>
    <name>Peter_Pan_666</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件工程</title>
    <link href="https://www.peterpan666.com/2020/01/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>https://www.peterpan666.com/2020/01/08/软件工程/</id>
    <published>2020-01-08T01:33:29.000Z</published>
    <updated>2020-01-16T04:25:00.810Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h4><p>1.按软件的功能进行划分，软件可划分为<u>系统软件</u>、<u>支撑软件</u>、<u>应用软件</u>。  2.软件生命周期由<u>软件定义</u>、<u>软件开发</u>和<u>运行维护</u>3个时期。每个时期又可进一步划分为若干阶段。其中，软件开发时期由<u>总体设计</u>、<u>详细设计</u>、<u>编码和单元测试</u>和<u>综合测试</u>4个阶段构成。<br>3.在可行性研究阶段，分析员要从<u>技术可行性</u>、<u>经济可行性</u>和<u>操作可行性</u>等方面来研究每种解决方案的可行性。<br>4.<u>内聚</u>标志着一个模块内部每个元素彼此结合的紧密程度，<u>耦合</u>是对一个软件结构内不同模块之间互联程度的度量。<br>5.面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法，因此，设计的过程就有了基于变换流的分析方法和基于<u>事务</u>流的分析方法两种。<br>6.软件体系结构通常可以看作是三个要素构成的，这三个要素分别是<u>构件</u>、<u>连接件</u>和<u>约束<br></u>。<strong><em>这三个是最基本要素，网上参考核心的五个要素是：构件、连接件、配置、端口和角色</em></strong><br>7.结构化方法有<u>结构化分析</u>、<u>结构化设计</u>、<u>结构化程序设计</u>它是一种面向数据流的开发方法。<br>结构化方法由<u>jiegouhua </u><br>8.决定软件的可维护性的5个主要因素分别是：<u>可理解性</u>、<u>可测试性</u>、<u>可修改性</u>、<u>可移植性</u>、<u>可重用性</u>。 9.在UML图中描述一个对象的生命周期的图是<u>状态图</u><br>10.在类图中，可见性包括<u>公有的</u>、<u>私有的</u>、<u>保护的</u>。11.程序的三种基本控制结构是<u>顺序</u>、<u>选择</u>、<u>循环</u>。</p><!--more--><h4 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h4><p>（F）1.软件的维护成本通常比开发成本低。<br>软件生命周期中所花费用最多的阶段是软件维护s<br>（T）2.HIPO法既是需求分析方法，又是软件设计方法。<br>（F）3.数据流图中需要描绘出数据流出现的条件。<br>DFD应该描绘所有可能的数据流向，而不应该描绘出现某个数据流的条件。<br>（T）4.用户界面设计对系统的成功至关重要，一个设计的很差的用户界面可能会导致用户拒绝使用该系统。<br>（F）5.逻辑覆盖测试中，满足条件覆盖的测试案例同时也满足判定覆盖。  <strong><em>不一定</em></strong><br>（F）6.结构图是精确表达程序结构的图形表示法。因此，有时也可以将系统的结构图当作系统流程图使用。</p><p>来自网络 系统流程图：反映主体框架；系统结构图：反映的是系统中模块的调用关系和层次关系,谁调用谁,有一个先后次序(时序)关系。两种图作用不同，不能互用<br>（F）7.状态图是UML中系统的静态方面进行建模的图之一。</p><p>来自PPT 静态建模有四种：用例图、类图、对象图、包图；动态建模有五种：消息、顺序图、协作图、活动图、状态图。</p><p>（T）8.顺序图由角色、对象、生命线、激活和消息组成。<br>（F）9.在等价类测试方法中，为了提高测试效率，一个测试用例可以覆盖多个无效等价类。<br>(T)10.在软件的生存周期中，工作量所占的比最大的阶段就是维护阶段。<br>(T)11.通过功能分解可以完成数据流图的细化<br>(F)12.当验收测试通过，软件开发就完成了。<br>–答案源自南昌大学期末卷多次出现，但是有疑惑，不知道原因<br>（T）13在模块化设计中，模块越小，模块的有点越明显。一般来说，模块的大小都在10行以下。</p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><p>1.请简要介绍一下软件工程的7个方面的本质特性<br>书上P6</p><p>2.简单论述软件体系结构的概念<br>具体见软件体系结构的PPT。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;体系结构是软件的总体框架，描述了软件系统的系统组织方式，包括构成系统的构件接口、行为模式、协作关系以及对这些问题的决策等信息；体系结构不仅设计到结构与行为，而且还涉及到系统的使用、功能、性能、适应性、重用性、可理解性、经济性和技术约束的均衡；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件体系结构是针对软件系统的规模和复杂性进行系统全局结构的设计和规划，包括全局组织结构；全局控制结构；通信和同步以及数据存取的协议；规定设计元素的功能；设计元素的组合；物理分布；规模和性能；演绎的维度；设计方案的选择等。<br>3.在设计黑盒测试方案时，应该考虑哪些方面的问题？<br>书P171-P172<br>4.请简单比较一下自顶向下和自底向上集成测试策略。<br>书P157-159<br>5.UML中协作图和顺序图的区别是什么？<br>（以下来自网络）时序图主要侧重于对象间消息传递在时间上的先后关系, 而协作图表达对象间的交互过程及对象间的关联关系，或者说为空间上的关系。<br>其余部分见两者定义再分析</p><h4 id="分析简答题"><a href="#分析简答题" class="headerlink" title="分析简答题"></a>分析简答题</h4><p>1.根据以下条件，试画出某高校财务系统中计算机教工出差补助的 <strong><em>判定表</em></strong><br>出差补助政策如下：<br>a）如果教工已经办理长期出差手续，则无论出差到哪里，出差补助都是每天80元<br>b）如果教工没有办理出差手续，则出差到一线城市，每天补助150元；出差到其他城市，每天补助100元；出差到偏远地区，每天补助300元。<br>c）如果教工本月未出差，无论是否办理长期出差手续，都没有出差补助。<br><img src="https://i.imgur.com/AD3O3Fh.jpg" alt="test4-1"></p><p>2.银行计算机储蓄系统的工作过程大致如下：储户填写的存款单或取款单有业务员键入系统，如果是存款则系统记录存款人姓名，住址（或电话号码）、身份证号码、存款类型、存款日期、到期日期、利率及密码（可选）等信息，并印出存单给储户：如果是取款而且存款对象留有密码，则系统首先核对储户密码，或密码正确或存款时为留密码，则系统计算利息并印出利息清单给储户。请用数据流图描绘本系统的功能。<br><img src="https://i.imgur.com/mGM8lOz.png" alt="test4-2"></p><h3 id="可行性研究时的图"><a href="#可行性研究时的图" class="headerlink" title="可行性研究时的图"></a>可行性研究时的图</h3><h4 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h4><p>系统流程图时概括地描绘<strong>物理系统</strong>的传统工具，基本思想是用图形符号以黑盒子的形式描绘组成系统的每个部件（程序、文档、数据库、人工过程等）。系统流程图表达的是<strong>数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程</strong>，因此尽管系统流程图的某系符号和程序流程图的符号形式相同，但是它确是物理数据流图而不是程序流程图。</p><h3 id="需求分析时的图"><a href="#需求分析时的图" class="headerlink" title="需求分析时的图"></a>需求分析时的图</h3><p>1.层次方框图（P68）：树形结构的的一系列多层次的矩形框描绘数据的层次结构，顶层单独的矩形框代表完整的数据结构，下面各层的矩形框代表数据的子集，最底层为不可再分割的元素。<br><img src="https://i.imgur.com/dsVhH8o.jpg" alt="层次方框图"><br>2.IPO图（P69）：描绘输入数据、对数据的处理和输出数据之间的关系。<br><img src="https://i.imgur.com/FpkrGZ8.jpg" alt="IPO"></p><h3 id="总体设计时的图"><a href="#总体设计时的图" class="headerlink" title="总体设计时的图"></a>总体设计时的图</h3><h4 id="层次图"><a href="#层次图" class="headerlink" title="层次图"></a>层次图</h4><p>1.层次图（P102），描绘模型层次结构，矩形框代表一个模块，方框的连线代表调用关系而不像层次方框图那样表示组成关系。<br><strong><em>层次图很适合自顶向下设计软件的过程中使用</em></strong><br><img src="https://i.imgur.com/SMO0vih.jpg" alt="层次图"></p><h4 id="hipo图"><a href="#HIPO图" class="headerlink" title="HIPO图"></a>HIPO图</h4><p>2.HIPO图（P103）：层次图加IPO，方框带上编号，每个方框对应一张IPO图描绘这个方框代表的模块的处理过程。<br><img src="https://i.imgur.com/BMCBI4h.jpg" alt="HIPO"></p><h4 id="结构图sc图"><a href="#结构图（SC图）" class="headerlink" title="结构图（SC图）"></a>结构图（SC图）</h4><p>3.结构图（P103）：描绘软件结构，方框代表一个模块，框内注明模块的名字或主要功能；方框之间的箭头（或直线）表示模块之间的调用关系。<strong><em>箭头尾部是空心圆表示传递的是数据，尾部是实心圆表示传递的是控制信息。</em></strong><br><img src="https://i.imgur.com/25oHNfS.jpg" alt="结构图"></p><h3 id="详细设计时的图"><a href="#详细设计时的图" class="headerlink" title="详细设计时的图"></a>详细设计时的图</h3><h4 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h4><h4 id="盒图ns图"><a href="#盒图（NS图）" class="headerlink" title="盒图（NS图）"></a>盒图（NS图）</h4><h4 id="pad图problem-analysis-diagram"><a href="#PAD图（Problem-Analysis-Diagram）" class="headerlink" title="PAD图（Problem Analysis Diagram）"></a>PAD图（Problem Analysis Diagram）</h4><h4 id="过程设计语言pdl"><a href="#过程设计语言（PDL）" class="headerlink" title="过程设计语言（PDL）"></a>过程设计语言（PDL）</h4><h2 id="umlunified-modeling-language"><a href="#UML（Unified-Modeling-Language）" class="headerlink" title="UML（Unified Modeling Language）"></a>UML（Unified Modeling Language）</h2><ul><li><strong><em>功能模型</em></strong>：从用户的角度展示系统的功能，包括用例图</li><li><strong><em>对象模型</em></strong>：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类图、对象图。</li><li><strong><em>动态模型</em></strong>：展现系统的内部行为。包括序列图，活动图，状态图。</li></ul><p><strong><em>UML图，包括用例图、协作图、活动图、序列图、部署图、构件图、类图、对象图、状态图，是模型中信息的图形表达方式，但是UML模型独立于UML图存在。</em></strong></p><h3 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h3><h4 id="构件图"><a href="#构件图" class="headerlink" title="构件图"></a>构件图</h4><h4 id="配置图"><a href="#配置图" class="headerlink" title="配置图"></a>配置图</h4><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><h4 id="动态建模"><a href="#动态建模" class="headerlink" title="动态建模"></a>动态建模</h4><p>动态建模：用来展示系统的行为<br>1.时序图：描述对象的交互过程.以时间为参考(强调的是时间顺序).<br>      虚线：(生命线)表示对象的生命周期.<br>      实线：对象消息.<br>      虚线：返回消息.<br>          长方形：活动(激活).<br>          叉：对象消亡.<br>2.协作图：跟时序图一样,但强调对象的连接关系.<br>3.状态图：描述对象的自身的状态(一个对象的类型不同可能行为很古怪,行为变化很大).<br>4.活动图：(类似于流程图)描述一个环境中的交互顺序.</p><h5 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h5><p>顺序图（sequence diagram） 描述对象间交互关系。<br>对象用矩形框表示，框内标对象名；<br>矩形框下的竖线代表对象的生命线；<br>对象生命线上的细长矩形框表示对象被激活；<br>对象间通信用对象间水平消息线表示，箭头形状表明消息类型（同步、异步或简单）。</p><h5 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h5><p>协作图（Collaboration diagram） 描述相互协作对象间交互关系和链接关系。<br>顺序图着重表现交互时间顺序；<br>协作图着重表现交互对象的静态链接消息；<br>协作图显示对象间处理过程的分布</p><h5 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h5><p>活动图（Activity diagram）描述为完成某一个用例需要做的活动以及这些活动的执行顺序。<br>活动图由状态图变化而来，各自用于不同目的。<br>状态图着重描述对象的状态变化以及触发状态变化的事件。<br>活动图着重描述各种活动的执行顺序。</p><h5 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h5><p>状态图：也即状态转换图，通过描述系统的状态及引起系统状态转换的事件来表示系统的行为，还指明了作为特定时间的结果系统将做哪些动作（例如处理数据）。状态图既可以表示循环运行过程，也可以表示系统单程生命期。</p><h4 id="静态建模"><a href="#静态建模" class="headerlink" title="静态建模"></a>静态建模</h4><p>静态建模：创建并建立一个系统的静态特征</p><p>1.用例图：描述系统功能及功能的使用者.<br>2.类  图：表现系统里实体的关系,责任,类和类之间的关系，属性及方法.<br>3.对象图：当类图不能完全显示关系时用对象图.描述对象的属性,对象名,方法.<br>4.组件图：对类功能的封装,一个组件包含多个类.<br>      虚线：表示依赖关系.<br>5.部署图：描述系统中的物理结构.<br>      实线：表示连接</p><h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><h5 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h5><h5 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h3&gt;&lt;h4 id=&quot;填空题&quot;&gt;&lt;a href=&quot;#填空题&quot; class=&quot;headerlink&quot; title=&quot;填
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://www.peterpan666.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://www.peterpan666.com/2019/09/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://www.peterpan666.com/2019/09/10/最小生成树/</id>
    <published>2019-09-10T06:18:04.000Z</published>
    <updated>2019-09-10T13:06:51.867Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1184/E1" target="_blank" rel="noopener">CF1184E1</a></p><a id="more"></a><p>题目要求：可改变第一条边的权值，求出第一条边的最大权值，使得第一条边能在最小生成树内。<br><strong>分析：第一条边一定在最小生成树内，则第一条边两端点的连通性只能由这第一条边建立。除去第一条边进行建立最小生成树，当第一条边两端点连通时，即得到最大值，可以走第一条边，而不走当前边</strong></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="hljs-meta-string">": "</span>&lt;&lt;a&lt;&lt;<span class="hljs-meta-string">'\n'</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span></span><br><span class="line">ll x,y,val;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="hljs-keyword">int</span> n,m;</span><br><span class="line">ll l = <span class="hljs-number">0</span>,r = <span class="hljs-number">1e9</span> + <span class="hljs-number">10</span>,mid;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge a,Edge b)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a.val &lt; b.val ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> head[maxn];</span><br><span class="line"><span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> _find(<span class="hljs-keyword">int</span> x)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(x == head[x])<span class="hljs-keyword">return</span> x;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> head[x] = _find(head[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">void</span> _union(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> hx = _find(x),hy = _find(y);</span><br><span class="line"><span class="hljs-keyword">if</span>(hx == hy)<span class="hljs-keyword">return</span>;</span><br><span class="line">head[hx] = hy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="hljs-literal">false</span>);</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].val;</span><br><span class="line">&#125;</span><br><span class="line">sort(edge+<span class="hljs-number">1</span>,edge+m,cmp);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;++i)head[i] = i;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; m;++i)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(_find(edge[i].x)!=_find(edge[i].y))&#123;</span><br><span class="line">head[_find(edge[i].x)] = _find(edge[i].y);</span><br><span class="line"><span class="hljs-keyword">if</span>(_find(edge[<span class="hljs-number">0</span>].x)==_find(edge[<span class="hljs-number">0</span>].y))&#123;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; edge[i].val;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">1000000000</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codeforces.com/problemset/problem/1184/E2" target="_blank" rel="noopener">CF1184E2</a><br><strong>紧接上题，对于任意的不在最小生成树上的边，修改这条边的权值，求解最大权值使该边能够在最小生成树上。</strong></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="hljs-meta-string">": "</span>&lt;&lt;a&lt;&lt;<span class="hljs-meta-string">'\n'</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> x,y,val;</span><br><span class="line"><span class="hljs-keyword">int</span> used,id;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="hljs-keyword">int</span> fa[maxn],head[maxn],ver[<span class="hljs-number">3</span>*maxn],nx[<span class="hljs-number">3</span>*maxn],wei[<span class="hljs-number">3</span>*maxn],tot;</span><br><span class="line"><span class="hljs-keyword">int</span> root,dep[maxn],rt[maxn][<span class="hljs-number">20</span>],dis[maxn],mx[maxn][<span class="hljs-number">20</span>];</span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span>&#123;</span><br><span class="line">ver[++tot] = y;wei[tot] = z;</span><br><span class="line">nx[tot] = head[x];head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> _find(<span class="hljs-keyword">int</span> x)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(x == fa[x])<span class="hljs-keyword">return</span> x;</span><br><span class="line"><span class="hljs-keyword">return</span> fa[x] = _find(fa[x]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge a,Edge b)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[x];i;i = nx[i])&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> y = ver[i];</span><br><span class="line"><span class="hljs-keyword">if</span>(dep[y])<span class="hljs-keyword">continue</span>;</span><br><span class="line">dep[y] = dep[x] + <span class="hljs-number">1</span>;</span><br><span class="line">dis[y] = dis[x] + wei[i];</span><br><span class="line">rt[y][<span class="hljs-number">0</span>] = x;</span><br><span class="line">mx[y][<span class="hljs-number">0</span>] = wei[i];</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(dep[u] &gt; dep[v])swap(u,v);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">19</span>;i &gt;= <span class="hljs-number">0</span>;--i)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(dep[rt[v][i]] &gt;= dep[u])v = rt[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">for(int i = 0;i &lt; 20;++i)&#123;</span></span><br><span class="line"><span class="hljs-comment">if((dep[v] - dep[u]) &amp; (1 &lt;&lt; i))v = rt[v][i];</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">if</span>(u == v)<span class="hljs-keyword">return</span> u;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">19</span>;i &gt;= <span class="hljs-number">0</span>;--i)</span><br><span class="line"><span class="hljs-keyword">if</span>(rt[u][i]!=rt[v][i])u = rt[u][i],v = rt[v][i];</span><br><span class="line"><span class="hljs-keyword">return</span> rt[u][<span class="hljs-number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lca_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> root)</span></span>&#123;</span><br><span class="line">dfs(root);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">20</span>;++j)&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">rt[i][j] = rt[rt[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];</span><br><span class="line">mx[i][j] = max(mx[i][j<span class="hljs-number">-1</span>],mx[rt[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> cha)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">20</span>;++i)</span><br><span class="line"><span class="hljs-keyword">if</span>(cha &amp; (<span class="hljs-number">1</span> &lt;&lt; i))res = max(res,mx[u][i]),u = rt[u][i];</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> w = lca(x,y);</span><br><span class="line"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;</span><br><span class="line">res = max(ask(x,<span class="hljs-built_in">abs</span>(dep[x]-dep[w])),ask(y,<span class="hljs-built_in">abs</span>(dep[y]-dep[w])));</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="hljs-literal">false</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> n,m;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;++i)<span class="hljs-built_in">cin</span> &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].val,edge[i].id = i;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)fa[i] = i;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;</span><br><span class="line">sort(edge + <span class="hljs-number">1</span>,edge + <span class="hljs-number">1</span> + m,cmp);</span><br><span class="line">tot =<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;++i)&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> hx = _find(edge[i].x),hy = _find(edge[i].y);</span><br><span class="line"><span class="hljs-keyword">if</span>(hx == hy)<span class="hljs-keyword">continue</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fa[hx] = hy;</span><br><span class="line">add(hx,hy,edge[i].val);</span><br><span class="line">add(hy,hx,edge[i].val);</span><br><span class="line">edge[i].used = <span class="hljs-number">1</span>;</span><br><span class="line">ans[edge[i].id] = <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root = <span class="hljs-number">1</span>;</span><br><span class="line">dep[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">lca_init(n,root);</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;++i)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(!edge[i].used)&#123;</span><br><span class="line">ans[edge[i].id] = query(edge[i].x,edge[i].y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;++i)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(ans[i]!=<span class="hljs-number">-1</span>)<span class="hljs-built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/1184/E1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CF1184E1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dp</title>
    <link href="https://www.peterpan666.com/2019/09/10/dp/"/>
    <id>https://www.peterpan666.com/2019/09/10/dp/</id>
    <published>2019-09-10T04:13:40.000Z</published>
    <updated>2019-09-10T04:46:18.511Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1183/problem/H" target="_blank" rel="noopener">CF1183H</a></p><a id="more"></a><p>线性$dp$，$dp[i][j]$表示前$i$个字符删去$j$个字符形成的不同的子序列，能够构成的本质不同的字符子串的个数。<br>状态转移： $\color{red}{ } dp[i][j]$ $\color{red}{ }= dp[i-1][j]$  $\color{red}{ } +$  $\color{red}{ }dp[i-1][j-1]$<br>可以由前$i-1$个字符删去$j$个，保留第$i$个字符的状态和前$i-1$个字符删去$j-1$个，并且删去第$i$个字符的状态转移过来。<br><strong>但是存在重复选取的情况，dp[i-1][j] 中以第i个字符结尾长度为i-j的字符子串也可能出现在dp[i-1][j-1]中，如果存在，需要减去。记录第i个字符上次出现的位置pos，以pos为结束的长度为i-j的字符子串个数即是重复个数。</strong>  </p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;</span><br><span class="line">ll pre[<span class="hljs-number">30</span>];</span><br><span class="line">ll dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];</span><br><span class="line"><span class="hljs-keyword">char</span> s[<span class="hljs-number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="hljs-literal">false</span>);</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)<span class="hljs-built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= i;++j)&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> pos = pre[s[i]-<span class="hljs-string">'a'</span>];</span><br><span class="line"><span class="hljs-keyword">if</span>(pos&amp;&amp;pos - i + j&gt;=<span class="hljs-number">0</span>)</span><br><span class="line">dp[i][j] -= dp[pos<span class="hljs-number">-1</span>][pos-i+j];</span><br><span class="line">&#125;</span><br><span class="line">pre[s[i]-<span class="hljs-string">'a'</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">ll cnt = <span class="hljs-number">0</span>;</span><br><span class="line">ll ans =<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//for(int i = 0;i&lt;=n;++i)cout &lt;&lt; dp[n][i] &lt;&lt; endl;</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(dp[n][j]&gt;=k)&#123;</span><br><span class="line">ans += k * j;</span><br><span class="line">k = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">k -= dp[n][j];</span><br><span class="line">ans += dp[n][j] * j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span>(k!=<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1183/problem/H&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CF1183H&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回文自动机PAM</title>
    <link href="https://www.peterpan666.com/2019/09/08/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BAPAM/"/>
    <id>https://www.peterpan666.com/2019/09/08/回文自动机PAM/</id>
    <published>2019-09-08T13:47:35.000Z</published>
    <updated>2019-09-08T16:08:06.204Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>模板<br>num[i]表示字符串第i个位置为止的后缀回文串中以第i个字母为结尾的回文串的个数；<br>cnt[i]表示本质不同回文串的个数，本质相同的回文串可能在字符串的多个位置出现。<br>cur 指向父亲回文串，当前回文串由父亲回文串拓展(+2)而来。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Palindrome_Aut</span>&#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> len[maxn],nx[maxn][<span class="hljs-number">26</span>],fail[maxn],cnt[maxn]; <span class="hljs-comment">//cnt 结点i表示的本质不同的串的个数,fail表示结点i失配后跳转不等于自身的结点i表示的回文串的最长后缀回文串 </span></span><br><span class="line"><span class="hljs-keyword">int</span> last,cur,S[maxn],p,n;     <span class="hljs-comment">//p为新建结点的返回值，S存储插入的字符串，n为总的串长,last记录最后新建的节点的索引,cur指向当前回文串的父亲串 </span></span><br><span class="line"><span class="hljs-keyword">int</span> num[maxn];       <span class="hljs-comment">//表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 </span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">25</span>;++i)nx[p][i] = <span class="hljs-number">0</span>;</span><br><span class="line">cnt[p] = <span class="hljs-number">0</span>;</span><br><span class="line">len[p] = l;</span><br><span class="line">num[p] = <span class="hljs-number">0</span>; </span><br><span class="line"><span class="hljs-keyword">return</span> p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">p = n = last = <span class="hljs-number">0</span>;</span><br><span class="line">newnode(<span class="hljs-number">0</span>);</span><br><span class="line">newnode(<span class="hljs-number">-1</span>);</span><br><span class="line">S[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;           <span class="hljs-comment">//加入任意一个串不会出现的字符 </span></span><br><span class="line">fail[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_fail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> <span class="hljs-keyword">while</span>(S[n-len[x] - <span class="hljs-number">1</span>]!=S[n])x = fail[x];</span><br><span class="line"> <span class="hljs-keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>&#123;     <span class="hljs-comment">//插入字符</span></span><br><span class="line">c -= <span class="hljs-string">'a'</span>; </span><br><span class="line">S[++n] = c;</span><br><span class="line"><span class="hljs-keyword">int</span> cur = get_fail(last);       <span class="hljs-comment">// </span></span><br><span class="line"><span class="hljs-keyword">if</span>(!nx[cur][c])&#123;      </span><br><span class="line"><span class="hljs-keyword">int</span> now = newnode(len[cur]+<span class="hljs-number">2</span>);</span><br><span class="line">fail[now] = nx[get_fail(fail[cur])][c];</span><br><span class="line">nx[cur][c] = now;</span><br><span class="line">num[now] = num[fail[now]] + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = nx[cur][c];</span><br><span class="line">cnt[last] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = p<span class="hljs-number">-1</span>;i &gt;=<span class="hljs-number">0</span>;--i)&#123;       <span class="hljs-comment">//逆序累加，保证每个点都会比它的父亲结点先算完，于是父亲节点能算加到所有子孙 </span></span><br><span class="line">cnt[fail[i]]+=cnt[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;run;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="hljs-literal">false</span>);</span><br><span class="line"><span class="hljs-built_in">string</span> s;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; s;</span><br><span class="line">run.init();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)run.add(s[i]);</span><br><span class="line">run.count();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;run.p;++i)<span class="hljs-built_in">cout</span> &lt;&lt; run.cnt[i];</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;模板&lt;br&gt;num[i]表示字符串第i个位置为止的后缀回文串中以第i个字母为结尾的回文串的个数；&lt;br&gt;cnt[i]表示本质不同回文串的个数，本质相同的回文串可能在字符串的多个位置出现。&lt;br&gt;cur 指向父亲回文串，当前回文串由父亲回文
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扩展kmp</title>
    <link href="https://www.peterpan666.com/2019/08/26/%E6%89%A9%E5%B1%95kmp/"/>
    <id>https://www.peterpan666.com/2019/08/26/扩展kmp/</id>
    <published>2019-08-26T11:11:11.000Z</published>
    <updated>2019-10-24T09:29:49.061Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="扩展kmp"><a href="#扩展kmp" class="headerlink" title="扩展kmp"></a>扩展kmp</h2><p>扩展kmp用来求解一个字符串的最长回文子串和最长重复子串。<br><a href="https://segmentfault.com/a/1190000008663857" target="_blank" rel="noopener">大佬讲得很详细,有图看起来也很清楚</a><br><del>在队友的帮助下，终于看懂了。</del><br>求解S串的每个后缀与T串的最长前缀匹配长度，需要用到T串每个后缀对T串的最长前缀匹配长度。由👆博客指出的规律，求$T$串的Next数组就相当于用一个与T串相同的$T’$串与T串扩展kmp，求解$T’$的extend就相当于T的Next数组。存储的是对任意前缀的非前缀子串与原串前缀匹配的最长后缀长度。</p><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><p>kmp 中的next数组存储的是以i结尾的非前缀子串与原串的前缀能够匹配的最长长度，匹配长度为$next[i],即子串$ $S[(i-(next[i]-1)),…,i]$  与子串 $S[1,…,next[i]]$匹配。 <strong><em>(下标从1开始)</em></strong><br>扩展kmp中的next[i]含义为：S[i]…S[n]与S的最长相同前缀长度，n为S串的长度，下标从1开始。存储对每一个后缀而言的最长前缀匹配长度。   </p><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><p>字符串首尾相连，找到一个位置，从该位置向后形成的字符串字典序最小。<br>模板：<br>定义i，j，k。<br>i，j为比较的两字符串的头，k为匹配长度</p><pre><code class="c++"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="built_in">string</span> s)</span></span>{  <span class="comment">//返回下标</span>    <span class="keyword">int</span> len = s.length();    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">1</span>,k = <span class="number">0</span>,t;    <span class="keyword">while</span>(i&lt; len &amp;&amp; j &lt; len &amp;&amp; k &lt; len){        t = s[(i+k)%len]  - s[(j+k)%len];        <span class="keyword">if</span>(!t)k++; <span class="comment">//字符串相等，匹配长度加一 </span>        <span class="keyword">else</span>{            <span class="keyword">if</span>(t &gt; <span class="number">0</span>)i += k+<span class="number">1</span>; <span class="comment">//i串比j串更大，直接跳过之前匹配的相同的部分长度k </span>            <span class="keyword">else</span> j += k + <span class="number">1</span>; <span class="comment">//j串比i串字典序更大，直接跳过之前匹配的相同的部分长度k </span>            <span class="keyword">if</span>(i == j) j++; <span class="comment">// 将字符串起点设置在不同的地方 </span>            k = <span class="number">0</span>;        }    }    <span class="keyword">return</span> i &gt; j ? j : i;  }</code></pre><p>模板题：<a href="https://vjudge.net/problem/POJ-1509" target="_blank" rel="noopener">POJ - 1509</a>  </p><h2 id="z-function"><a href="#Z-function" class="headerlink" title="Z-function"></a>Z-function</h2><p>定义一个函数z()，z(i)是指由s[i]开始的字串，与s[0]开始的字串可以匹配到多长。也就是说 s[0…z(i)−1]=s[i…i+z(i)−1]。即存储从i开始的原串的后缀与原串的前缀的的最长前缀匹配长度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;扩展kmp&quot;&gt;&lt;a href=&quot;#扩展kmp&quot; class=&quot;headerlink&quot; title=&quot;扩展kmp&quot;&gt;&lt;/a&gt;扩展kmp&lt;/h2&gt;&lt;p&gt;扩展kmp用来求解一个字符串的最长回文子串和最长重复子串。&lt;br&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ac自动机</title>
    <link href="https://www.peterpan666.com/2019/08/26/Ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>https://www.peterpan666.com/2019/08/26/Ac自动机/</id>
    <published>2019-08-26T07:23:09.000Z</published>
    <updated>2019-08-26T10:48:06.055Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>解决多模式串，一个文本串问题。<br>例如：多模式串中有多少种在文本串中出现<a href="https://www.luogu.org/problem/P3808" target="_blank" rel="noopener">P3808 【模板】AC自动机（简单版）</a><br>多模式串在文本串中出现最多的模式串及次数<a href="https://www.luogu.org/problem/P3796" target="_blank" rel="noopener">P3796 【模板】AC自动机（加强版）</a><br>多模式串中每个模式串在文本串中出现的次数+查询优化<a href="https://www.luogu.org/problem/P5357" target="_blank" rel="noopener">P5357 【模板】AC自动机（二次加强版）</a><br>我最开始学习使用的是kuangbin的模板，在模板的基础上修改就能过各种简单题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;解决多模式串，一个文本串问题。&lt;br&gt;例如：多模式串中有多少种在文本串中出现&lt;a href=&quot;https://www.luogu.org/problem/P3808&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P380
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排列组合问题</title>
    <link href="https://www.peterpan666.com/2019/08/10/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>https://www.peterpan666.com/2019/08/10/排列组合问题/</id>
    <published>2019-08-10T14:27:47.000Z</published>
    <updated>2019-08-10T14:29:58.897Z</updated>
    
    <content type="html"><![CDATA[<p>感谢前人总结，学到了各种的解法<a href="https://blog.csdn.net/qwb492859377/article/details/50654627" target="_blank" rel="noopener"><br>排列组合 “n个球放入m个盒子m”问题 总结</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢前人总结，学到了各种的解法&lt;a href=&quot;https://blog.csdn.net/qwb492859377/article/details/50654627&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;br&gt;排列组合 “n个球放入m个盒子m”问题 总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初等数论</title>
    <link href="https://www.peterpan666.com/2019/07/29/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"/>
    <id>https://www.peterpan666.com/2019/07/29/初等数论/</id>
    <published>2019-07-29T12:51:13.000Z</published>
    <updated>2019-07-29T13:16:14.836Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>判定一个自然数是否为素数的必要充分条件。<br>当且仅当$p$为素数时：$（p-1）!$ $\equiv-1$ ( mod $p$)。</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若$p$是质数，对任意整数$a$,$a^p\equiv$ a( mod $p$)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;威尔逊定理&quot;&gt;&lt;a href=&quot;#威尔逊定理&quot; class=&quot;headerlink&quot; title=&quot;威尔逊定理&quot;&gt;&lt;/a&gt;威尔逊定理&lt;/h3&gt;&lt;p&gt;判定一个自然数是否为素数的必要充分条件。&lt;br&gt;当且仅当$p$为素数时：$（p-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性基</title>
    <link href="https://www.peterpan666.com/2019/07/23/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>https://www.peterpan666.com/2019/07/23/线性基/</id>
    <published>2019-07-22T16:04:25.000Z</published>
    <updated>2019-07-22T16:19:12.326Z</updated>
    
    <content type="html"><![CDATA[<p>对于线性基的解释可以参看<a href="https://blog.csdn.net/a_forever_dream/article/details/83654397" target="_blank" rel="noopener">大佬的博客</a>，比较好理解，分析证明都比较好。</p><h4 id="线性基一般可以处理序列异或和最大最小和异或结果第k小问题等有关异或的问题"><a href="#线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。" class="headerlink" title="线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。"></a>线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。</h4><a id="more"></a><p>代码模板：线性基异或和最大数据范围（2^50）<br><a href="https://www.luogu.org/problemnew/show/P3812" target="_blank" rel="noopener">洛谷P3812 【模板】线性基</a></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;</span><br><span class="line">ll a[<span class="hljs-number">55</span>],d[<span class="hljs-number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> _insert(ll x)&#123;            <span class="hljs-comment">//插入元素 </span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">49</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(x&amp;(ll(<span class="hljs-number">1</span>)&lt;&lt;i))&#123;               <span class="hljs-comment">//特别注意结果超出int范围，左移要加long long </span></span><br><span class="line"><span class="hljs-keyword">if</span>(d[i])x^=d[i];</span><br><span class="line"><span class="hljs-keyword">else</span>&#123;</span><br><span class="line">d[i] = x;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll _query()&#123;      <span class="hljs-comment">//贪心求异或和最大 </span></span><br><span class="line">ll ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i  = <span class="hljs-number">49</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>((ans^d[i])&gt;ans)ans= (ans)^d[i];      <span class="hljs-comment">//注意：异或结果比较时需要加上括号在进行比较，不然会出错 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="hljs-literal">false</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> n;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-built_in">cin</span> &gt;&gt; a[i],_insert(a[i]);</span><br><span class="line"><span class="hljs-built_in">cout</span> &lt;&lt; _query();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于线性基的解释可以参看&lt;a href=&quot;https://blog.csdn.net/a_forever_dream/article/details/83654397&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大佬的博客&lt;/a&gt;，比较好理解，分析证明都比较好。&lt;/p&gt;
&lt;h4 id=&quot;线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。&quot;&gt;&lt;a href=&quot;#线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。&quot; class=&quot;headerlink&quot; title=&quot;线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。&quot;&gt;&lt;/a&gt;线性基一般可以处理序列异或和最大，最小和异或结果第k小问题等有关异或的问题。&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>递推</title>
    <link href="https://www.peterpan666.com/2019/07/20/%E9%80%92%E6%8E%A8/"/>
    <id>https://www.peterpan666.com/2019/07/20/递推/</id>
    <published>2019-07-19T16:09:02.000Z</published>
    <updated>2019-07-19T16:18:27.493Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Yukina and ball<br>Description</p><p>Yukina最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了NN个不同的球，想把它们放到MM个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上B站看游泳教练，于是他向你求助。</p><p>Input</p><p>多组数据，每行两个数N,M (1 \le N, M \le 20)N,M(1≤N,M≤20)。</p><p>Output</p><p>每组数据一行，表示方案数。</p><p>Sample Input 1 </p><p>4 2<br>1 1<br>Sample Output 1</p><p>71<br>题解：<br>设f[i][j]为前i个球放在前j个盒子里的方案数。<br>将前i-1个球放在j个盒子里，再把第i个球放在任意一个盒子里 $j<em>f[i-1][j]$<br>将前i-1个球放在j-1个盒子里，把i单独放在一个新盒子里  $f[i-1][j-1]$<br>递推式：$f[i][j] = j</em>f[i-1][j] + f[i-1][j-1]$<br>递推题老想不到，<del>自己太笨了</del>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Yukina and ball&lt;br&gt;Description&lt;/p&gt;
&lt;p&gt;Yukina最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了NN个不同的球，想把它们放到MM个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>完全背包</title>
    <link href="https://www.peterpan666.com/2019/07/18/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <id>https://www.peterpan666.com/2019/07/18/完全背包/</id>
    <published>2019-07-18T13:22:04.000Z</published>
    <updated>2019-07-18T13:41:00.057Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>完全背包的应用，将一个数拆成多个数（可重复）的组合，求方案数。<br>如果，求不同素数组合的方案数，则变为01背包求方案数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;完全背包的应用，将一个数拆成多个数（可重复）的组合，求方案数。&lt;br&gt;如果，求不同素数组合的方案数，则变为01背包求方案数。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>三分法</title>
    <link href="https://www.peterpan666.com/2019/07/16/%E4%B8%89%E5%88%86%E6%B3%95/"/>
    <id>https://www.peterpan666.com/2019/07/16/三分法/</id>
    <published>2019-07-16T09:35:31.000Z</published>
    <updated>2019-07-16T09:38:48.915Z</updated>
    
    <content type="html"><![CDATA[<p>第一次搞三分法，懵逼，之后来补题和题解。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次搞三分法，懵逼，之后来补题和题解。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高精度</title>
    <link href="https://www.peterpan666.com/2019/07/14/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>https://www.peterpan666.com/2019/07/14/高精度/</id>
    <published>2019-07-14T06:00:21.000Z</published>
    <updated>2019-07-14T06:05:12.401Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1080" target="_blank" rel="noopener">P1080 国王游戏</a></p><a id="more"></a><p>代码：<br>写得头皮发麻，虽然不是最简单的版本，但是也算思路清晰，不同题目再相应处理就行。之后有更简洁的版本在更新。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 5e2+5;</span><br><span class="line">/*</span><br><span class="line">加减乘除，处理放在外面</span><br><span class="line">也可以不用数组，用字符串每位模拟，最后返回字符串 </span><br><span class="line">*/</span><br><span class="line">int a[MAXN],b[MAXN],c[MAXN]; //用两个数组存储每一位,a,b存数，c存结果</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void add(string s1,string s2)&#123;        //正整数数相加,输出的结果一定为正 </span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">memset(b,0,sizeof(b));</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">a[0] = s1.length();      //记录s1的长度</span><br><span class="line">b[0] = s2.length();   //记录s2的长度</span><br><span class="line">for(int i = 1;i&lt;=s1.length();++i)a[i] = s1[a[0]-i]-&apos;0&apos;; //将s1每一位转化成整数倒序放入a数组</span><br><span class="line">for(int i = 1;i&lt;=s2.length();++i)b[i] = s2[b[0]-i]-&apos;0&apos;;  //将每一位转化成整数倒序放入b数组 </span><br><span class="line">int len = max(a[0],b[0]);       //去长度更大的</span><br><span class="line">int cnt =0;    //进位标志 </span><br><span class="line">for(int i = 1;i&lt;=len;++i)&#123;               //按位加法 </span><br><span class="line">c[i] = (a[i]+b[i]+cnt)%10;</span><br><span class="line">cnt = (a[i]+b[i]+cnt)/10;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt)&#123;      //最后还有进位的话，多添加一位 </span><br><span class="line">c[len+1] = 1;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">c[0] = len;</span><br><span class="line">for(int i = c[0];i&gt;=1;--i)&#123;</span><br><span class="line">cout &lt;&lt; c[i] ;             //按位输出; </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int cmp(int a[],int b[])&#123;       //高进度正整数比较 ,a&lt;b返回-1，a==b返回0，a&gt;b返回1 </span><br><span class="line">if(a[0]&lt;b[0])return -1;</span><br><span class="line">else if(a[0]&gt;b[0])return 1;</span><br><span class="line">else&#123;</span><br><span class="line">for(int i = a[0];i&gt;=1;--i)&#123;     //从高位比较到低位 </span><br><span class="line">if(a[i]&lt;b[i])return -1;</span><br><span class="line">else if(a[i]&gt;b[i])return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">/*</span><br><span class="line">减法注意运算后结果为0的高位应该忽略。 </span><br><span class="line">*/</span><br><span class="line">void subtract(string s1,string s2)&#123;         //a-b 正整数相加减，结果可正可负 </span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">memset(b,0,sizeof(b));</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">int flag = 1,cnt =0; //记录符号位,借位符（低位是否需要借位） </span><br><span class="line">a[0] = s1.length();b[0] = s2.length();</span><br><span class="line">for(int i = 1;i&lt;=s1.length();++i)a[i] = s1[a[0]-i] - &apos;0&apos;;</span><br><span class="line">for(int i = 1;i&lt;=s2.length();++i)b[i] = s2[b[0]-i] - &apos;0&apos;;</span><br><span class="line">if(cmp(a,b)==-1)&#123;         //如果 a小于b </span><br><span class="line">flag = -1;</span><br><span class="line">for(int i = 1;i&lt;=b[0];++i)&#123;</span><br><span class="line">c[i] = b[i]-a[i]-cnt;</span><br><span class="line">cnt = 0;</span><br><span class="line">if(c[i]&lt;0)&#123;</span><br><span class="line">c[i]+=10;cnt = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(int i = 1;i&lt;=a[0];++i)&#123;</span><br><span class="line">c[i] = a[i]-b[i]-cnt;</span><br><span class="line">cnt = 0;</span><br><span class="line">if(c[i]&lt;0)&#123;</span><br><span class="line">c[i]+=10;cnt = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag == -1)cout &lt;&lt; &apos;-&apos;;</span><br><span class="line">int len = max(a[0],b[0]);     //做减法时高位减小到0，则忽略</span><br><span class="line">for(int i = len;i&gt;=1&amp;&amp;len&gt;1;--i) //len&gt;1,保证最少返回0 </span><br><span class="line">if(c[i]==0)len--;</span><br><span class="line">else break;         </span><br><span class="line">c[0]  = len;</span><br><span class="line">for(int i = c[0];i&gt;=1;--i)cout &lt;&lt; c[i];</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void multi(string s1,string s2)&#123;      //正整数相乘 ，符号位在函数外处理 ，结果一定为正 </span><br><span class="line">int flag = 1;           //记录结果是否为负数 </span><br><span class="line">//if(s1[0]==&apos;-&apos;)flag*=-1,s1.erase(0,1);</span><br><span class="line">//if(s2[0]==&apos;-&apos;)flag*=-1,s2.erase(0,1); </span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">memset(b,0,sizeof(b));</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">a[0] = s1.length();b[0] = s2.length();</span><br><span class="line">for(int i = 1;i&lt;=s1.length();++i)a[i] = s1[a[0]-i] - &apos;0&apos;;</span><br><span class="line">for(int i = 1;i&lt;=s2.length();++i)b[i] = s2[b[0]-i] - &apos;0&apos;;</span><br><span class="line">for(int i = 1;i&lt;=a[0];++i)</span><br><span class="line">for(int j = 1;j&lt;=b[0];++j)</span><br><span class="line">&#123;</span><br><span class="line">c[i+j-1] += a[i]*b[j];</span><br><span class="line">c[i+j] += c[i+j-1] / 10;</span><br><span class="line">c[i+j-1] %= 10;</span><br><span class="line">&#125;</span><br><span class="line">if(flag == -1)cout &lt;&lt; &apos;-&apos;;</span><br><span class="line">int len = a[0] + b[0] + 1;          //可能产生进位，从最高位前一位开始找结果的头。</span><br><span class="line">while(c[len]==0&amp;&amp;len&gt;1)len--;         //len&gt;1保证最后至少返回0 </span><br><span class="line">c[0] = len;</span><br><span class="line">for(int i = c[0];i&gt;=1;--i)&#123;</span><br><span class="line">cout &lt;&lt; c[i] ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void div1(string s1,ll s2)&#123;       //高精度正整数除以低精度正整数 ，符号在函数外判断，结果一定为正 </span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">a[0] = s1.length();</span><br><span class="line">for(int i = 1;i &lt;= s1.length();++i)a[i] = s1[i-1] - &apos;0&apos;;</span><br><span class="line">ll tem = 0;    //tem记录前一位剩下的部分的值 </span><br><span class="line">for(int i = 1;i&lt;=a[0];++i)&#123;</span><br><span class="line">c[i] = (tem*10 + a[i])/s2;</span><br><span class="line">tem = (tem*10+a[i])%s2;</span><br><span class="line">&#125;</span><br><span class="line">int l = 1,r = a[0];    //结果的左右边界； </span><br><span class="line">for(int i = l;i&lt;=r;++i)&#123;</span><br><span class="line">if(c[i]!=0)&#123;</span><br><span class="line">l = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = l;i&lt;=r;++i)cout &lt;&lt; c[i];</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">void subduction(int a[],int b[])&#123;      //a = a-b;此处的a。b数组中都还是倒序存储的</span><br><span class="line">int flag = cmp(a,b);</span><br><span class="line">int i;</span><br><span class="line">if(flag == 0)&#123;</span><br><span class="line">a[0] = 0;return ;      //a被减完了   </span><br><span class="line">&#125;</span><br><span class="line">if(flag == 1)&#123;</span><br><span class="line">for(int i = 1;i&lt;=a[0];++i)&#123;</span><br><span class="line">if(a[i]&lt;b[i])&#123;</span><br><span class="line">a[i+1]--;</span><br><span class="line">a[i] += 10;</span><br><span class="line">&#125;</span><br><span class="line">a[i] -= b[i];</span><br><span class="line">&#125;</span><br><span class="line">while(a[0]&gt;0&amp;&amp;a[a[0]]==0)a[0]--;          //消除前导零 </span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void div2(string s1,string s2)&#123;        //正整数高精除以正整数高精 </span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">memset(b,0,sizeof(b));</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">a[0] = s1.length();b[0] = s2.length();</span><br><span class="line">for(int i =1;i&lt;=a[0];++i)a[i] = s1[a[0]-i]-&apos;0&apos;;</span><br><span class="line">for(int i =1;i&lt;=b[0];++i)b[i] = s2[b[0]-i]-&apos;0&apos;;</span><br><span class="line">int tem[MAXN];</span><br><span class="line">c[0] = a[0]-b[0]+1;</span><br><span class="line">for(int i = c[0];i&gt;=1;--i)&#123;  //i对应结果倒序的下标 </span><br><span class="line">memset(tem,0,sizeof(tem));</span><br><span class="line">for(int j = 1;j&lt;=b[0];++j)tem[i+j-1] = b[j];   //倒序存储tem，从对应下标位置存储b，得到b的倍数与的当前的a进行比较 </span><br><span class="line">//for(int j = i+b[0]-1;j&gt;=1;--j)cout &lt;&lt; tem[j];</span><br><span class="line">//cout &lt;&lt; endl;</span><br><span class="line">tem[0] = b[0]+ i-1; </span><br><span class="line">while(cmp(a,tem)&gt;=0)&#123;      //对应位上使用减法 </span><br><span class="line">c[i]++;</span><br><span class="line">subduction(a,tem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(c[0]&gt;0&amp;&amp;c[c[0]]==0)c[0]--;     //去除前导零 </span><br><span class="line">cout &lt;&lt; &quot;商为:&quot;; </span><br><span class="line">if(c[0]==0)&#123;</span><br><span class="line">cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">for(int i = c[0];i&gt;=1;--i)&#123;</span><br><span class="line">cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;余数为；&quot;;</span><br><span class="line">if(a[0]==0)&#123;</span><br><span class="line">cout &lt;&lt; 0 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">for(int i = a[0];i&gt;=1;--i)&#123;</span><br><span class="line">cout &lt;&lt; a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P1080 国王游戏
&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全排列及康拓展开</title>
    <link href="https://www.peterpan666.com/2019/07/11/%E5%85%A8%E6%8E%92%E5%88%97%E5%8F%8A%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80/"/>
    <id>https://www.peterpan666.com/2019/07/11/全排列及康拓展开/</id>
    <published>2019-07-11T04:53:32.453Z</published>
    <updated>2019-07-11T10:03:46.470Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1088" target="_blank" rel="noopener">P1088 火星人</a></p><p>1、会使用next_permutation函数<br>2、了解算法，手写next_permutation函数<br>3、学习使用康拓展开和逆康拓展开</p><a id="more"></a><h2 id="next_permutation"><a href="#Next-permutation" class="headerlink" title="Next_permutation"></a>Next_permutation</h2><p>算法描述：<br>每次从后往前找第一个可以修改的位置m（判断条件：当前元素a[m]小于后一个元素a[m+1]），再从后往前找第一个大于需修改位置的元素的位置n(判断条件a[n]&gt;a[m])。<strong><em>修改位置的后面是降序的，找到的第一个大于a[i]的数一定是后面大于a[m]的数中最小的</em></strong>。交换a[m],a[n]。<strong><em>交换完后面的序列还是降序的，我们需要得到最小的序列，所以需要进行一次倒序操作</em></strong>。</p><p>代码实现（c++）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int num[100];</span><br><span class="line">int next(int l,int r,int num[])&#123;      //数组的左右端 ,数组从1开始 </span><br><span class="line">if(l==r)return;</span><br><span class="line">int m =0,n =0;</span><br><span class="line">for(int i = r-1;l&gt;=l;--i)&#123;       //找需要修改的位置m </span><br><span class="line">if(num[i]&lt;num[i+1])&#123;</span><br><span class="line">m = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(m==0)retunr 0; //说明序列已经最大了 全排列结束，返回0 </span><br><span class="line">for(int i = r;i&gt;=l;--i)&#123;          //找第一个大于num【m】元素的位置 </span><br><span class="line">if(num[i]&gt;num[m])&#123;</span><br><span class="line">n = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swnump(num[m],num[n]);</span><br><span class="line">m++; </span><br><span class="line">n = r;</span><br><span class="line">while(m&lt;n)&#123;            //参照位置之后倒序 </span><br><span class="line">swap(num[m],num[n]);</span><br><span class="line">m++;n--;</span><br><span class="line">&#125;</span><br><span class="line">return 1;           //有下一个全排列，返回1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="康拓展开"><a href="#康拓展开" class="headerlink" title="康拓展开"></a>康拓展开</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1088&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P1088 火星人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、会使用next_permutation函数&lt;br&gt;2、了解算法，手写next_permutation函数&lt;br&gt;3、学习使用康拓展开和逆康拓展开&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://www.peterpan666.com/2019/07/10/B%E6%A0%91/"/>
    <id>https://www.peterpan666.com/2019/07/10/B树/</id>
    <published>2019-07-10T13:52:55.000Z</published>
    <updated>2019-07-10T16:33:37.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="b-树平衡多路查找树"><a href="#B-树（平衡多路查找树）" class="headerlink" title="B-树（平衡多路查找树）"></a>B-树（平衡多路查找树）</h2><p>若为m阶B-树。<br>定义及性质：<br>1、结点至多m棵子树（对应m阶B树）；<br>2、非叶子节点最少有两棵子树；<br>3、除根之外所有非终端结点至少 $\lceil$ $m\over2$$\rceil$棵子树;<br>4、非终端结点包含以下信息（$n,A_0,K_1,A_1,K_2,,,K_n,A_n$）;n表示结点上关键字个数，$K_i$对应关键字，$A_i$对应指向子树的根节点。由此我们可知，子树个数等于关键字个数加一，由于阶数限制，又由于性质3，所以关键字个数n（$\lceil$ $m \over 2$ $\rceil$ $\leq$ $n$ $\leq$ $m-1$）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;b-树平衡多路查找树&quot;&gt;&lt;a href=&quot;#B-树（平衡多路查找树）&quot; class=&quot;headerlink&quot; title=&quot;B-树（平衡多路查找树）&quot;&gt;&lt;/a&gt;B-树（平衡多路查找树）&lt;/h2&gt;&lt;p&gt;若为m阶B-树。&lt;br&gt;定义及性质：&lt;br&gt;1、结点至多m棵子树
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最短路</title>
    <link href="https://www.peterpan666.com/2019/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>https://www.peterpan666.com/2019/07/10/最短路/</id>
    <published>2019-07-10T13:40:39.000Z</published>
    <updated>2019-09-04T08:31:21.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><p>思路：贪心</p><ul><li>记录到起点的距离数组dis，初始化起点到起点距离为0，其他都设置为无穷大，后面再更新。设置标记数组f，标记即代表已经寻找到最短路。</li><li>标记起点，然后按照起点的出边更新起点到其他点的距离。</li><li>在距离矩阵中找最短的没有被标记的点，标记该点后，继续按照出边更新，直至全部顶点都被标记。  </li><li>vis数组标记点是否已经达到最优解，根据贪心思想，每次出队时元素已经达到最优解，将该点标记。</li></ul><p>优先队列维护的思想：优先队列（小根堆）维护各点到起点的距离，每次都找最近的未被标记的顶点，然后标记，更新。</p><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><ul><li>迭代思想，不断更新。</li><li>vis数组记录当前点是否在队列里，保证队列里没有重复元素   </li><li><strong>slf优化*</strong>  </li><li><strong>求最短路时，将更新完的距离跟队列头的进行比较，比队首更小就放在队首，不然就放在队尾*</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dijkstra&quot;&gt;&lt;a href=&quot;#dijkstra&quot; class=&quot;headerlink&quot; title=&quot;dijkstra&quot;&gt;&lt;/a&gt;dijkstra&lt;/h2&gt;&lt;p&gt;思路：贪心&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录到起点的距离数组dis，初始化起点到起点距离为0，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://www.peterpan666.com/2019/07/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://www.peterpan666.com/2019/07/09/并查集/</id>
    <published>2019-07-09T11:32:58.000Z</published>
    <updated>2020-01-16T03:45:59.729Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1196" target="_blank" rel="noopener">P1196 [NOI2002]银河英雄传说</a></p><a id="more"></a><p>代码先附上，题解过两天补。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">3e4</span>+<span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> head[MAXN],size[MAXN],dis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(head[x]==x)<span class="hljs-keyword">return</span> head[x];</span><br><span class="line"><span class="hljs-keyword">int</span> k = head[x];</span><br><span class="line">head[x] = find(head[x]);</span><br><span class="line">dis[x] += dis[k];</span><br><span class="line"><span class="hljs-keyword">return</span> head[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UNION</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> dx = find(a);</span><br><span class="line"><span class="hljs-keyword">int</span> dy = find(b);</span><br><span class="line">dis[dx]+=size[dy];</span><br><span class="line">size[dy]+=size[dx];</span><br><span class="line">head[dx] = dy;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> t;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;MAXN;++i)size[i] = <span class="hljs-number">1</span>,head[i]  = i,dis[i] =<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">char</span> ch;</span><br><span class="line"><span class="hljs-keyword">int</span> a,b;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line"><span class="hljs-built_in">cin</span> &gt;&gt; ch &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'M'</span>)UNION(a,b);</span><br><span class="line"><span class="hljs-keyword">else</span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> dx = find(a);</span><br><span class="line"><span class="hljs-keyword">int</span> dy = find(b);</span><br><span class="line"><span class="hljs-keyword">if</span>(dx!=dy)<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">abs</span>(dis[a]-dis[b])<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">for(int i =1;i&lt;=5;++i)&#123;</span></span><br><span class="line"><span class="hljs-comment">cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1196&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P1196 [NOI2002]银河英雄传说&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.peterpan666.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>FTP记住密码后的麻烦解决</title>
    <link href="https://www.peterpan666.com/2019/07/04/FTP%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%90%8E%E7%9A%84%E9%BA%BB%E7%83%A6%E8%A7%A3%E5%86%B3/"/>
    <id>https://www.peterpan666.com/2019/07/04/FTP记住密码后的麻烦解决/</id>
    <published>2019-07-04T07:08:59.000Z</published>
    <updated>2019-07-04T07:12:22.197Z</updated>
    
    <content type="html"><![CDATA[<p>转载自我自己之前<a href="https://blog.csdn.net/qq_40655345/article/details/84146214" target="_blank" rel="noopener">CSDN的博客</a><br>在大一的时候我学校里计算机相关的老师会让我们在ftp服务器上下载作业，我才开始接触ftp服务器。在一次使用时点击了保存密码的选项，之后的登陆就变得很不愉快了。因为记住密码的原因，每次登陆ftp服务器，都会自动进入之前保存的那个用户，无法在同一个服务器上其他的账户上下载东西，也就是当时不知道如何切换到那个服务器上的其他账户。</p><p>在网上查阅了近2个小时的方法，才找到了能够解决这个问题的办法，也就是一个登陆ftp服务器的万用方法。</p><pre><code>ftp://用户名:密码@地址</code></pre><p>通过这个方式就可以在已保存密码的情况下，登陆其他的用户了。</p><p>希望能帮助到那些萌新小白新生，希望能让那些急于寻找解决办法的人，不要像我那样浪费了很多时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自我自己之前&lt;a href=&quot;https://blog.csdn.net/qq_40655345/article/details/84146214&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN的博客&lt;/a&gt;&lt;br&gt;在大一的时候我学校里计算机相
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分图</title>
    <link href="https://www.peterpan666.com/2019/07/04/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://www.peterpan666.com/2019/07/04/二分图/</id>
    <published>2019-07-04T03:13:03.000Z</published>
    <updated>2019-08-28T11:58:28.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>无向图G的二分图的充分必要条件：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G至少有两个点；对于G中每条回路长度得是偶数。</span><br></pre></td></tr></table></figure><p>匹配</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于G的一个子图M，M的边集中任何两条边都不依附于同一个点，则称这个边集是一个匹配，匹配的数量由边数决定。(可以理解左右两堆点，一一匹配，左边的点只能跟右边的一个点匹配)</span><br></pre></td></tr></table></figure><p>完美匹配</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配中所有顶点都是匹配的点。</span><br></pre></td></tr></table></figure><p>交替路</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边形成的路径。</span><br></pre></td></tr></table></figure><p>增广路</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从一个未匹配点出发，走交替路，途经另一位匹配点，这段路成为增广路，即未匹配边未匹配边加一。</span><br></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>通过增广路不断“反色”求解最大匹配的问题。<br>二分图最大匹配模板<a href="https://www.luogu.org/problem/P3386" target="_blank" rel="noopener">P3386 【模板】二分图匹配</a><br>二分图最大匹配<a href="https://www.luogu.org/problem/P1640" target="_blank" rel="noopener">P1640 [SCOI2010]连续攻击游戏</a>,理解运用二分图，使用时间戳优化。<br>二分图最大匹配<a href="https://www.acwing.com/problem/content/374/" target="_blank" rel="noopener">372. 棋盘覆盖 </a>理解二分图中的<strong>0要素</strong>和<strong>1要素</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;无向图G的二分图的充分必要条件：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu</title>
    <link href="https://www.peterpan666.com/2019/07/03/Ubuntu/"/>
    <id>https://www.peterpan666.com/2019/07/03/Ubuntu/</id>
    <published>2019-07-03T03:00:50.000Z</published>
    <updated>2020-01-16T03:45:40.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ubuntu-安装在vmware上"><a href="#Ubuntu-安装在VMware上" class="headerlink" title="Ubuntu 安装在VMware上"></a>Ubuntu 安装在VMware上</h2><p>笔记本安装遇到的分辨率和刷新率的问题，先使用设置中调整分辨率再进行安装</p><h4 id="vmware-tool文件复制到桌面之后再提取到主目录不然会报错"><a href="#VMware-Tool文件复制到桌面之后再提取到主目录，不然会报错" class="headerlink" title="VMware Tool文件复制到桌面之后再提取到主目录，不然会报错"></a>VMware Tool文件复制到桌面之后再提取到主目录，不然会报错</h4><h4 id="共享文件夹老挂载不上"><a href="#共享文件夹老挂载不上，" class="headerlink" title="共享文件夹老挂载不上，"></a>共享文件夹老挂载不上，</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ubuntu-安装在vmware上&quot;&gt;&lt;a href=&quot;#Ubuntu-安装在VMware上&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 安装在VMware上&quot;&gt;&lt;/a&gt;Ubuntu 安装在VMware上&lt;/h2&gt;&lt;p&gt;笔记本安装遇到的分辨
      
    
    </summary>
    
    
  </entry>
  
</feed>
